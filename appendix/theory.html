<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Theory - Pikelet Language Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for the Pikelet Language">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "../";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="../index.html">Pikelet</a></li><li><a href="../installation/index.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li><a href="../language/index.html"><strong aria-hidden="true">2.</strong> Language</a></li><li><ol class="section"><li><a href="../language/conditionals.html"><strong aria-hidden="true">2.1.</strong> Conditionals</a></li><li><a href="../language/records.html"><strong aria-hidden="true">2.2.</strong> Records</a></li><li><a href="../language/functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li><a href="../language/modules.html"><strong aria-hidden="true">2.4.</strong> Modules</a></li><li><a href="../language/type-inference.html"><strong aria-hidden="true">2.5.</strong> Type inference</a></li><li><a href="../language/universes.html"><strong aria-hidden="true">2.6.</strong> Universes</a></li></ol></li><li><a href="../appendix/index.html"><strong aria-hidden="true">3.</strong> Appendix</a></li><li><ol class="section"><li><a href="../appendix/design.html"><strong aria-hidden="true">3.1.</strong> Design</a></li><li><a href="../appendix/theory.html" class="active"><strong aria-hidden="true">3.2.</strong> Theory</a></li><li><a href="../appendix/influences.html"><strong aria-hidden="true">3.3.</strong> Influences</a></li><li><a href="../appendix/references.html"><strong aria-hidden="true">3.4.</strong> References</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Pikelet Language Book</h1> 

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#theory" id="theory"><h1>Theory</h1></a>
<p>A formalization of the semantics for type checking and normalizing Pikelet.</p>
<a class="header" href="#contents" id="contents"><h2>Contents</h2></a>
<ul>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#notation">Notation</a></li>
<li><a href="#where-is-the-soundness-proof">Where is the soundness proof?</a></li>
</ul>
</li>
<li><a href="#syntax">Syntax</a>
<ul>
<li><a href="#raw-terms">Raw terms</a></li>
<li><a href="#terms">Terms</a></li>
<li><a href="#values">Values</a></li>
<li><a href="#contexts">Contexts</a></li>
</ul>
</li>
<li><a href="#semantics">Semantics</a>
<ul>
<li><a href="#elaboration">Elaboration</a></li>
<li><a href="#normalization">Normalization</a></li>
<li><a href="#type-checking">Type checking</a></li>
<li><a href="#type-inference">Type inference</a></li>
<li><a href="#subtyping">Subtyping</a></li>
<li><a href="#universe-shifting">Universe shifting</a></li>
<li><a href="#pattern-matching">Pattern matching</a></li>
<li><a href="#type-checking-of-patterns">Type checking of patterns</a></li>
<li><a href="#type-inference-of-patterns">Type inference of patterns</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction" id="introduction"><h2>Introduction</h2></a>
<p>At its core, Pikelet is a dependently typed lambda calculus with a cumulative
universe hierarchy with explicit level shifts.</p>
<blockquote>
<p><strong>Note:</strong>
This document is intended for those who are interested in looking deeper into the formal foundations of Pikelet.
You <em>don't</em> need to understand this for general use of Pikelet, so feel free to skip this document if that is easier.
We will however make an effort to explain some of the notation we use here, and point to resources that might help if this piques your curiosity!</p>
</blockquote>
<a class="header" href="#notation" id="notation"><h3>Notation</h3></a>
<p>We use a combination of some <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a>-style syntax definitions with
<a href="natural-deduction">natural deduction</a> rules to define our language. This
combination of notation is sometimes referred to as <em>computer science
metanotation</em> and is, alas, a little hard to pin down <a href="https://www.youtube.com/watch?v=7HKbjYqqPPQ">as conventions vary</a>
between papers and authors. The general rules stay the same however, and once
you learn to read them they are much more succinct than an actual implementation
could be, and are an invaluable tool for quickly getting a high-level overview
of a programming language's semantics.</p>
<blockquote>
<p><strong>TODO:</strong>
Describe BNF, natural deduction rules, overbars, variable binding, etc.</p>
</blockquote>
<p>Some handy links:</p>
<ul>
<li><a href="http://siek.blogspot.com.au/2012/07/crash-course-on-notation-in-programming.html">Crash Course on Notation in Programming Language Theory</a></li>
<li><a href="https://blog.acolyer.org/2018/01/26/a-practitioners-guide-to-reading-programming-languages-papers/">A practitioner’s guide to reading programming languages papers</a></li>
<li><a href="http://steshaw.org/plt/">A path to enlightenment in Programming Language Theory</a></li>
</ul>
<a class="header" href="#where-is-the-soundness-proof" id="where-is-the-soundness-proof"><h3>Where is the soundness proof?</h3></a>
<p>Here we are only defining the rules of our language's type checking and
evaluation. Further work needs to be done to verify that our system actually
satisfies certain interesting <a href="https://en.wikipedia.org/wiki/Type_safety">type soundness properties</a>,
like progress, preservation, <a href="https://en.wikipedia.org/wiki/Normalization_property_(abstract_rewriting)">strong normalization</a>,
etc. If you would like to discuss this with us, please check out
<a href="https://github.com/pikelet-lang/pikelet/issues/39">the relevant github issue</a>!</p>
<a class="header" href="#syntax" id="syntax"><h2>Syntax</h2></a>
<a class="header" href="#raw-terms" id="raw-terms"><h3>Raw terms</h3></a>
<p>\[
% Haskell-style append https://tex.stackexchange.com/questions/4194/how-to-typeset-haskell-operator-and-friends
\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
% Small caps https://github.com/mathjax/MathJax-docs/wiki/Small-caps-%5Ctextsc-in-MathJaxx
\def\sc#1{\dosc#1\csod}
\def\dosc#1#2\csod{{\rm #1{\small #2}}}
\
\newcommand{\rule}[3]{ \dfrac{ ~~#2~~ }{ ~~#3~~ } &amp; \Tiny{\text{(#1)}} }
\
\DeclareMathOperator{\max}{max}
\DeclareMathOperator{\field}{field}
\DeclareMathOperator{\fieldty}{fieldty}
\DeclareMathOperator{\fieldsubst}{fieldsubst}
\DeclareMathOperator{\Match}{\sc{MATCH}}
\DeclareMathOperator{\shift}{shift}
\
% Judgments
\newcommand{\eval}[3]{ #1 \vdash #2 \hookrightarrow #3 }
\newcommand{\check}[4]{ #1 \vdash #2 \uparrow #3 \leadsto #4 }
\newcommand{\infer}[4]{ #1 \vdash #2 \downarrow #3 \leadsto #4 }
\newcommand{\subty}[3]{ #1 \vdash #2 \preccurlyeq #3 }
\newcommand{\match}[3]{ \Match(#1,#2) \Longrightarrow #3 }
\newcommand{\checkpat}[5]{ #1 \vdash #2 \uparrow #3 \leadsto #4 \Longrightarrow #5 }
\newcommand{\inferpat}[5]{ #1 \vdash #2 \downarrow #3 \leadsto #4 \Longrightarrow #5 }
\
% Metavariables
\newcommand{\rexpr}{r} % raw expressions
\newcommand{\rtype}{R} % raw types
\newcommand{\rpat}{s}  % raw patterns
\
\newcommand{\texpr}{t} % expressions
\newcommand{\ttype}{T} % types
\newcommand{\tpat}{p}  % patterns
\
\newcommand{\vexpr}{v} % value expressions
\newcommand{\vtype}{V} % value types
\newcommand{\wexpr}{w} % whnf expressions
\newcommand{\wtype}{W} % whnf types
\newcommand{\nexpr}{n} % neutral expressions
\newcommand{\ntype}{N} % neutral types
\
\newcommand{\ctx}{\Gamma} % contexts
\
% Keywords
\newcommand{\kw}[1]{ \mathsf{#1} }
\
% Term and Type constructors
\newcommand{\label}{l}
\newcommand{\binder}{x}
\newcommand{\var}[1]{x^{#1}}
\newcommand{\Type}[1]{\kw{Type}^{#1}}
% \newcommand{\var}[1]{x^\wedge#1}
% \newcommand{\Type}[1]{\kw{Type}^\wedge#1}
\newcommand{\Arrow}[2]{ #1 \rightarrow #2 }
\newcommand{\Pi}[2]{ \Arrow{(#1)}{#2} }
\newcommand{\lam}[2]{ \kw{\lambda} #1 . #2 }
\newcommand{\app}[2]{ #1 ~ #2 }
\newcommand{\case}[2]{ \kw{case} ~ #1 \left\{ #2 \right\} }
\newcommand{\RecordCons}[2]{ \kw{Record} \left\{ #1; #2 \right\} }
\newcommand{\RecordEmpty}{ \kw{Record} \left\{\right\} }
\newcommand{\as}{ ~ \kw{as} ~ }
\newcommand{\record}[1]{ \kw{record} \left\{ #1 \right\} }
\newcommand{\subst}[3]{ #1 ~ [#2 \rightarrow #3] }
\
% Items
\newcommand{\declItem}[2]{ #1 : #2 }
\newcommand{\defnItem}[2]{ #1 = #2 }
\
% Contexts
\newcommand{\emptyCtx}{ \varnothing }
\newcommand{\composeCtx}[2]{ #1 \sim #2 }
\newcommand{\extendCtx}[2]{ #1, #2 }
\
\begin{array}{rrll}
\rexpr,\rtype   &amp; ::= &amp; \var{i}                             &amp; \text{variables ($i \in \mathbb{N}$)} \\
&amp;   | &amp; \Type{i}                            &amp; \text{universe of types ($i \in \mathbb{N}$)} \\
&amp;   | &amp; ?                                   &amp; \text{holes} \\
&amp;   | &amp; \rexpr : \rtype                     &amp; \text{term annotated with a type} \\
&amp;   | &amp; \Pi{\binder:\rtype_1}{\rtype_2}     &amp; \text{dependent function type} \\
&amp;   | &amp; \lam{\binder:\rtype}{\rexpr}        &amp; \text{functions} \\
&amp;   | &amp; \app{\rexpr_1}{\rexpr_2}            &amp; \text{function application} \\
&amp;   | &amp; \case{\rexpr}{\overline{\rpat_i \rightarrow \rexpr_i}^{;}} &amp; \text{case expressions} \\
&amp;   | &amp; \RecordCons{\label \as \binder:\rtype_1}{\rtype_2} &amp; \text{record type extension} \\
&amp;   | &amp; \RecordEmpty                        &amp; \text{empty record type} \\
&amp;   | &amp; \record{\label=\rexpr_1, \rexpr_2}  &amp; \text{record extension} \\
&amp;   | &amp; \record{}                           &amp; \text{empty record} \\
&amp;   | &amp; \rexpr.\label                       &amp; \text{record projection} \\
\\
\rpat           &amp; ::= &amp; \binder                             &amp; \text{binder pattern} \\
&amp;   | &amp; \rpat : \rtype                      &amp; \text{pattern annotated with a type} \\
%   &amp;   | &amp; \record{\label=\rpat_1, \rpat_2}    &amp; \text{record extension pattern} \\
%   &amp;   | &amp; \record{}                           &amp; \text{empty record pattern} \\
\\
\end{array}
\]</p>
<p>\[
\begin{array}{lrll}
\Arrow{\rtype_1}{\rtype_2} &amp; := &amp; \Pi{\binder:\rtype_1}{\rtype_2} &amp; \text{non-dependent function types} \\
\lam{\binder}{\rexpr}      &amp; := &amp; \lam{\binder:?}{\rexpr}         &amp; \text{functions (without an annotation)} \\
\end{array}
\]</p>
<a class="header" href="#terms" id="terms"><h3>Terms</h3></a>
<p>The core term syntax skips holes, ensuring that everything is fully elaborated:</p>
<p>\[
\begin{array}{rrll}
\texpr,\ttype   &amp; ::= &amp; \var{i}                             &amp; \text{variables ($i \in \mathbb{N}$)} \\
&amp;   | &amp; \Type{i}                            &amp; \text{universe of types ($i \in \mathbb{N}$)} \\
&amp;   | &amp; \texpr : \ttype                     &amp; \text{term annotated with a type} \\
&amp;   | &amp; \Pi{\binder:\ttype_1}{\ttype_2}     &amp; \text{dependent function type} \\
&amp;   | &amp; \lam{\binder:\ttype}{\texpr}        &amp; \text{functions} \\
&amp;   | &amp; \app{\texpr_1}{\texpr_2}            &amp; \text{function application} \\
&amp;   | &amp; \case{\texpr}{\overline{\tpat_i \rightarrow \texpr_i}^{;}} &amp; \text{case expressions} \\
&amp;   | &amp; \RecordCons{\label \as \binder:\ttype_1}{\ttype_2} &amp; \text{record type extension} \\
&amp;   | &amp; \RecordEmpty                        &amp; \text{empty record type} \\
&amp;   | &amp; \record{\label=\texpr_1, \texpr_2}  &amp; \text{record extension} \\
&amp;   | &amp; \record{}                           &amp; \text{empty record} \\
&amp;   | &amp; \texpr.\label                       &amp; \text{record projection} \\
\\
\tpat           &amp; ::= &amp; \binder                             &amp; \text{binder pattern} \\
&amp;   | &amp; \tpat : \ttype                      &amp; \text{pattern annotated with a type} \\
&amp;   | &amp; \record{\label=\tpat_1, \tpat_2}    &amp; \text{record extension pattern} \\
&amp;   | &amp; \record{}                           &amp; \text{empty record pattern} \\
\\
\end{array}
\]</p>
<a class="header" href="#values" id="values"><h3>Values</h3></a>
<p>In order to make it clear what is 'stuck' and what still needs to be evaluated,
we separate our syntax into <a href="https://en.wikipedia.org/wiki/Lambda_calculus_definition#Weak_head_normal_form">weak head normal forms</a> (\(\wexpr\)),
and neutral terms (\(\nexpr\)):</p>
<p>\[
\begin{array}{rrll}
\vexpr,\vtype   &amp; ::= &amp; \wexpr                              &amp; \text{weak head normal forms} \\
&amp;   | &amp; \nexpr                              &amp; \text{neutral terms} \\
\\
\nexpr,\ntype   &amp; ::= &amp; \var{i}                             &amp; \text{variables ($i \in \mathbb{N}$)} \\
&amp;   | &amp; \app{\nexpr}{\texpr}                &amp; \text{function application} \\
&amp;   | &amp; \case{\nexpr}{\overline{\tpat_i \rightarrow \texpr_i}^{;}} &amp; \text{case expressions} \\
&amp;   | &amp; \nexpr.\label                       &amp; \text{record projection} \\
\\
\wexpr,\wtype   &amp; ::= &amp; \Type{i}                            &amp; \text{universe of types ($i \in \mathbb{N}$)} \\
&amp;   | &amp; \Pi{\binder:\vtype_1}{\vtype_2}     &amp; \text{dependent function type} \\
&amp;   | &amp; \lam{\binder:\vtype}{\vexpr}        &amp; \text{functions} \\
&amp;   | &amp; \RecordCons{\label \as \binder:\vtype_1}{\vtype_2} &amp; \text{record type extension} \\
&amp;   | &amp; \RecordEmpty                        &amp; \text{empty record type} \\
&amp;   | &amp; \record{\label=\vexpr_1, \vexpr_2}  &amp; \text{record extension} \\
&amp;   | &amp; \record{}                           &amp; \text{empty record} \\
\\
\end{array}
\]</p>
<a class="header" href="#contexts" id="contexts"><h3>Contexts</h3></a>
<p>As we type check terms, we'll be passing over bindings like lambdas and pi types.
Contexts allow us to keep track of the bound parameters,
even though we don't know the exact values these will eventually take during normalization.</p>
<p>\[
\begin{array}{rrll}
\ctx    &amp; ::= &amp; \emptyCtx                                      &amp; \text{the empty context} \\
&amp;   | &amp; \extendCtx{\ctx}{\declItem{\binder}{\vtype}}   &amp; \text{context extended with a declaration} \\
&amp;   | &amp; \extendCtx{\ctx}{\defnItem{\binder}{\texpr}}   &amp; \text{context extended with a definition} \\
\end{array}
\]</p>
<a class="header" href="#semantics" id="semantics"><h2>Semantics</h2></a>
<p>We take a <em>bidirectional</em> approach to type checking, splitting it into two
phases: type checking and type inference. This makes the flow of information
through the type checker clear and relatively easy to reason about.
Normalization happens after inference, and before types are fed back in to be
used during type checking.</p>
<p>With that in mind, the next sections will describe the following judgments:</p>
<table><thead><tr><th> Name                                                      </th><th> Notation                                                      </th><th> Inputs                                    </th><th> Outputs                                   </th></tr></thead><tbody>
<tr><td> <a href="#normalization">normalization</a>                           </td><td> \(\eval{ \ctx }{ \texpr }{ \vexpr }\)                       </td><td> \(\ctx\), \(\rexpr\)                  </td><td> \(\vexpr\)                              </td></tr>
<tr><td> <a href="#type-checking">type checking</a>                           </td><td> \(\check{ \ctx }{ \rexpr }{ \vtype }{ \texpr }\)            </td><td> \(\ctx\), \(\rexpr\), \(\vtype\)    </td><td> \(\texpr\)                              </td></tr>
<tr><td> <a href="#type-inference">type inference</a>                         </td><td> \(\infer{ \ctx }{ \rexpr }{ \vtype }{ \texpr }\)            </td><td> \(\ctx\), \(\rexpr\)                  </td><td> \(\vtype\), \(\texpr\)                </td></tr>
<tr><td> <a href="#subtyping">subtyping</a>                                   </td><td> \(\subty{ \ctx }{ \vtype_1 }{ \vtype_2 }\)                  </td><td> \(\ctx\), \(\vtype_1\), \(\vtype_2\)</td><td>                                           </td></tr>
<tr><td> <a href="#pattern-matching">pattern matching</a>                     </td><td> \(\match{ \wexpr }{ \tpat }{ \theta }\)                     </td><td> \(\wexpr\), \(\tpat\)                 </td><td> \(\theta\)                              </td></tr>
<tr><td> <a href="#type-checking-of-patterns">type checking of patterns</a>   </td><td> \(\checkpat{ \ctx }{ \rpat }{ \vtype }{ \tpat }{ \ctx' }\)  </td><td> \(\ctx\), \(\rpat\), \(\vtype\)     </td><td> \(\tpat\), \(\ctx'\)                  </td></tr>
<tr><td> <a href="#type-inference-of-patterns">type inference of patterns</a> </td><td> \(\inferpat{ \ctx }{ \rpat }{ \vtype }{ \tpat }{ \ctx' }\)  </td><td> \(\ctx\), \(\rpat\),                  </td><td> \(\vtype\), \(\tpat\), \(\ctx'\)    </td></tr>
</tbody></table>
<p>Normalization stands on its own, but both checking and inference are mutually
dependent on each other. Care has been taken to design the judgments so that
they are <em>syntax-directed</em>, meaning that an algorithm can be clearly derived
from them.</p>
<a class="header" href="#elaboration" id="elaboration"><h3>Elaboration</h3></a>
<p>Elaboration is the process of filling in missing information that the
programmer omitted in the original code, generally based on the results
of type inference.</p>
<p>In Pikelet's judgements the elaborated terms are denoted after the
diamond: \(\rhd\). At the moment not much is added - only the missing
type annotations on function parameters. In the future this could be extended
filling in type class instances and implicit arguments.</p>
<a class="header" href="#normalization" id="normalization"><h3>Normalization</h3></a>
<p>Here we describe how we normalize elaborated terms under the assumptions
in the context.</p>
<p>\[
\boxed{
\eval{ \ctx }{ \texpr }{ \vexpr }
}
\\[2em]
\begin{array}{cl}
\rule{E-ANN}{
\eval{ \ctx }{ \texpr }{ \vexpr }
}{
\eval{ \ctx }{ \texpr:\ttype }{ \vexpr }
}
\\[2em]
\rule{E-TYPE}{}{
\eval{ \ctx }{ \Type{i} }{ \Type{i} }
}
\\[2em]
\rule{E-VAR}{
\defnItem{\binder}{\texpr} \notin \ctx
}{
\eval{ \ctx }{ \var{i} }{ \var{i} }
}
\\[2em]
\rule{E-VAR-DEF}{
\defnItem{\binder}{\texpr} \in \ctx
\qquad
\eval{ \ctx }{ \texpr }{ \vexpr }
}{
\eval{ \ctx }{ \var{i} }{ \shift(\vexpr,i) }
}
\\[2em]
\rule{E-PI}{
\eval{ \ctx }{ \ttype_1 }{ \vtype_1 }
\qquad
\eval{ \ctx }{ \ttype_2 }{ \vtype_2 }
}{
\eval{ \ctx }{ \Pi{\binder:\ttype_1}{\ttype_2} }{ \Pi{\binder:\vtype_1}{\vtype_2} }
}
\\[2em]
\rule{E-LAM}{
\eval{ \ctx }{ \ttype }{ \vtype }
\qquad
\eval{ \ctx }{ \texpr }{ \vexpr }
}{
\eval{ \ctx }{ \lam{\binder:\ttype}{\texpr} }{ \lam{\binder:\vtype}{\vexpr} }
}
\\[2em]
\rule{E-APP}{
\eval{ \ctx }{ \texpr_1 }{ \lam{\binder:\vtype_1}{\vexpr_1} }
\qquad
\eval{ \ctx }{ \subst{\vexpr_1}{\binder}{\texpr_2} }{ \vexpr_3 }
}{
\eval{ \ctx }{ \app{\texpr_1}{\texpr_2} }{ \vexpr_3 }
}
\\[2em]
\rule{E-CASE}{
\eval{ \ctx }{ \nexpr }{ \nexpr' }
}{
\eval{ \ctx }{ \case{\nexpr}{\overline{\tpat_i \rightarrow \texpr_i}^{;}} }
{ \case{\nexpr'}{\overline{\tpat_i \rightarrow \texpr_i}^{;}} }
}
\\[2em]
\rule{E-CASE-MATCH}{
\eval{ \ctx }{ \nexpr }{ \wexpr }
\qquad
\match{ \wexpr }{ \tpat_i }{ \theta }
\qquad
\eval{ \ctx }{ \texpr_i ~ \theta }{ \vexpr_i }
}{
\eval{ \ctx }{ \case{\nexpr}{\overline{\tpat_i \rightarrow \texpr_i}^{;}} }{ \vexpr_i }
}
\\[2em]
\rule{E-RECORD-TYPE}{
\eval{ \ctx }{ \ttype_1 }{ \vtype_1 }
\qquad
\eval{ \ctx }{ \ttype_2 }{ \vtype_2 }
}{
\eval{ \ctx }{ \RecordCons{\label \as \binder:\ttype_1}{\ttype_2} }{ \RecordCons{\label \as \binder:\vtype_1}{\vtype_2} }
}
\\[2em]
\rule{E-RECORD}{
\eval{ \ctx }{ \texpr_1 }{ \vexpr_1 }
\qquad
\eval{ \ctx }{ \texpr_2 }{ \vexpr_2 }
}{
\eval{ \ctx }{ \record{\label=\texpr_1, \texpr_2} }{ \record{\label=\vexpr_1, \vexpr_2} }
}
\\[2em]
\rule{E-EMPTY-RECORD-TYPE}{}{
\eval{ \ctx }{ \RecordEmpty }{ \RecordEmpty }
}
\\[2em]
\rule{E-EMPTY-RECORD}{}{
\eval{ \ctx }{ \record{} }{ \record{} }
}
\\[2em]
\rule{E-PROJ}{
\eval{ \ctx }{ \texpr_1 }{ \vexpr_1 }
\qquad
\vexpr_2 = \field(\label, \vexpr_1)
}{
\eval{ \ctx }{ \texpr_1.\label }{ \vexpr_2 }
}
\\[2em]
\end{array}
\]</p>
<p>We define \(\field(-,-)\) like so:</p>
<p>\[
\begin{array}{lrll}
\field(\label_1, \record{\label_2 = \vexpr_1, \vexpr_2}) &amp; = &amp; \vexpr_1 &amp; \text{if} ~ \label_1 \equiv \label_2 \\
\field(\label_1, \record{\label_2 = \vexpr_1, \vexpr_2}) &amp; = &amp; \field(\label_1, \vexpr_2) \\
\end{array}
\]</p>
<a class="header" href="#type-checking" id="type-checking"><h3>Type checking</h3></a>
<p>This judgement checks that the given term has the expected type and returns its
elaborated form.</p>
<p>\[
\boxed{
\check{ \ctx }{ \rexpr }{ \vtype }{ \texpr }
}
\\[2em]
\begin{array}{cl}
\rule{C-LAM}{
\infer{ \extendCtx{\ctx}{\declItem{\binder}{\vtype_1}} }{ \rexpr }{ \ttype_2 }{ \texpr }
}{
\check{ \ctx }{ \lam{\binder}{\rexpr} }{ \Pi{\binder:\vtype_1}{\vtype_2} }{ \lam{\binder:\vtype_1}{\texpr} }
}
\\[2em]
\rule{C-CASE}{
\infer{ \ctx }{ \rexpr }{ \vtype_1 }{ \texpr }
\qquad
\overline{
% TODO: impl pattern checks
~
\check{ \ctx }{ \rpat_i }{ \vtype_1 }{ \tpat_i } \Rightarrow \ctx'
\qquad
\check{ \composeCtx{\ctx}{\ctx'} }{ \rexpr_i }{ \vtype_2 }{ \texpr_i }
~
}
}{
\check{ \ctx }{ \case{\rexpr}{\overline{\rpat_i \rightarrow \rexpr_i}^{;}} }{ \vtype_2 }
{ \case{\texpr}{\overline{\tpat_i \rightarrow \texpr_i}^{;}} }
}
\\[2em]
\rule{C-RECORD}{
\label_1 \equiv \label_2
\qquad
\check{ \ctx }{ \rexpr_1 }{ \vtype_1 }{ \texpr_1 }
\qquad
\eval{ \ctx }{ \subst{\vtype_2}{\binder}{\texpr_1} }{ \vtype_3 }
\qquad
\check{ \ctx }{ \rexpr_2 }{ \vtype_3 }{ \texpr_2 }
}{
\check{ \ctx }{ \record{\label_1=\rexpr_1, \rexpr_2} }
{ \RecordCons{\label_2 \as \binder:\vtype_1}{\vtype_2} }
{ \record{\label_1=\texpr_1, \texpr_2} }
}
\\[2em]
\rule{C-CONV}{
\infer{ \ctx }{ \rexpr }{ \vtype_2 }{ \texpr }
\qquad
\subty{ \ctx }{ \vtype_1 }{ \vtype_2 }
}{
\check{ \ctx }{ \rexpr }{ \vtype_1 }{ \texpr }
}
\\[2em]
\end{array}
\]</p>
<a class="header" href="#type-inference" id="type-inference"><h3>Type inference</h3></a>
<p>Here we define a judgement that synthesizes a type from the given term and
returns its elaborated form.</p>
<p>\[
\boxed{
\infer{ \ctx }{ \rexpr }{ \vtype }{ \texpr }
}
\\[2em]
\begin{array}{cl}
\rule{I-ANN}{
\infer{ \ctx }{ \rtype }{ \Type{i} }{ \ttype }
\qquad
\eval{ \ctx }{ \ttype }{ \vtype }
\qquad
\check{ \ctx }{ \rexpr }{ \vtype }{ \texpr }
}{
\infer{ \ctx }{ \rexpr:\rtype }{ \Type{i+1} }{ \texpr:\ttype }
}
\\[2em]
\rule{I-TYPE}{}{
\infer{ \ctx }{ \Type{i} }{ \Type{i+1} }{ \Type{i} }
}
\\[2em]
\rule{I-VAR}{
\declItem{\binder}{\vtype} \in \ctx
}{
\infer{ \ctx }{ \var{i} }{ \shift(\vtype,i) }{ \var{i} }
}
\\[2em]
\rule{I-PI}{
\infer{ \ctx }{ \rtype_1 }{ \Type{i} }{ \ttype_1 }
\qquad
\eval{ \ctx }{ \ttype_1 }{ \vtype_1 }
\qquad
\check{ \extendCtx{\ctx}{\declItem{\binder}{\vtype_1}} }{ \rtype_2 }{ \Type{j} }{ \ttype_2 }
}{
\infer{ \ctx }{ \Pi{\binder:\rtype_1}{\rtype_2} }{ \Type{\max(i,j)} }
{ \Pi{\binder:\ttype_1}{\ttype_2} }
}
\\[2em]
\rule{I-LAM}{
\infer{ \ctx }{ \rtype }{ \Type{i} }{ \ttype }
\qquad
\eval{ \ctx }{ \ttype }{ \vtype_1 }
\qquad
\check{ \extendCtx{\ctx}{\declItem{\binder}{\vtype_1}} }{ \rexpr}{ \vtype_2 }{ \texpr }
}{
\infer{ \ctx }{ \lam{\binder:\rtype}{\rexpr} }
{ \Pi{\binder:\vtype_1}{\vtype_2} }{ \lam{\binder:\ttype}{\texpr} }
}
\\[2em]
\rule{I-APP}{
\infer{ \ctx }{ \rexpr_1 }{ \Pi{\binder:\vtype_1}{\vtype_2} }{ \texpr_1 }
\qquad
\check{ \ctx }{ \rexpr_2 }{ \vtype_1 }{ \texpr_2 }
\qquad
\eval{ \ctx }{ \subst{\vtype_2}{\binder}{\texpr_2} }{ \vtype_3 }
}{
\infer{ \ctx }{ \app{\rexpr_1}{\rexpr_2} }{ \vtype_3 }{ \app{\texpr_1}{\texpr_2} }
}
\\[2em]
\rule{I-RECORD-TYPE}{
\infer{ \ctx }{ \rtype_1 }{ \Type{i} }{ \ttype_1 }
\qquad
\eval{ \ctx }{ \ttype_1 }{ \vtype_1 }
\qquad
\infer{ \extendCtx{\ctx}{\declItem{\binder}{\vtype_1}} }{ \rtype_2 }{ \Type{j} }{ \ttype_2 }
}{
\infer{ \ctx }
{ \RecordCons{\label \as \binder:\rtype_1}{\rtype_2} }
{ \Type{\max(i,j)} }
{ \RecordCons{\label \as \binder:\ttype_1}{\ttype_2} }
}
\\[2em]
\rule{I-EMPTY-RECORD-TYPE}{}{
\infer{ \ctx }{ \RecordEmpty }{ \Type{0} }{ \RecordEmpty }
}
\\[2em]
\rule{I-RECORD}{
\infer{ \ctx }{ \rexpr_1 }{ \vtype_1 }{ \texpr_1 }
\qquad
\infer{ \ctx }{ \rexpr_2 }{ \vtype_2 }{ \texpr_2 }
\qquad
\eval{ \ctx }{ \subst{\vtype_2}{\binder}{\texpr_1} }{ \vtype_3 }
}{
\infer{ \ctx }{ \record{\label=\rexpr_1, \rexpr_2} }
{ \RecordCons{\label \as \binder:\vtype_1}{\vtype_3} }
{ \record{\label=\texpr_1, \texpr_2} }
}
\\[2em]
\rule{I-EMPTY-RECORD}{}{
\infer{ \ctx }{ \record{} }{ \RecordEmpty }{ \record{} }
}
\\[2em]
\rule{I-PROJ}{
\infer{ \ctx }{ \rexpr }{ \vtype_1 }{ \texpr }
\qquad
\vtype_2 = \fieldty(\label, \vtype_1)
\qquad
\theta = \fieldsubst(\texpr, \label, \vtype_1)
}{
\infer{ \ctx }{ \rexpr.\label }{ \vtype_2 ~ \theta }{ \texpr.\label }
}
\\[2em]
\end{array}
\]</p>
<p>We define \(\fieldty(-,-)\) and \(\fieldsubst(-,-,-)\) like so:</p>
<p>\[
\begin{array}{lrll}
\fieldty(\label_1, \RecordCons{\label_2 : \vtype_1}{\vtype_2}) &amp; = &amp; \vtype_1 &amp; \text{if} ~ \label_1 \equiv \label_2 \\
\fieldty(\label_1, \RecordCons{\label_2 : \vtype_1}{\vtype_2}) &amp; = &amp; \fieldty(\label_1, \vtype_2) \\
\\[2em]
\end{array}
\]</p>
<p>In order to ensure that we maintain maintain the proper paths to variables when
we project on them, we define \(\fieldsubst(-,-,-)\) as:</p>
<p>\[
\begin{array}{lrll}
\fieldsubst(\texpr, \label_1, \RecordCons{\label_2 : \vtype_1}{\vtype_2}) &amp; =
&amp; [] &amp; \text{if} ~ \label_1 \equiv \label_2 \\
\fieldsubst(\texpr, \label_1, \RecordCons{\label_2 : \vtype_1}{\vtype_2}) &amp; =
&amp; \fieldsubst(\texpr, \label_1, \vtype_2) \doubleplus [ \label_2 \rightarrow \texpr.\label_2 ] \\
\\[2em]
\end{array}
\]</p>
<a class="header" href="#subtyping" id="subtyping"><h3>Subtyping</h3></a>
<p>\[
\boxed{
\subty{ \ctx }{ \vtype_1 }{ \vtype_2 }
}
\\[2em]
\begin{array}{cl}
\rule{ST-TYPE}{
i \leqslant j
}{
\subty{ \ctx }{ \Type{i} }{ \Type{j} }
}
\\[2em]
\rule{ST-PI}{
\subty{ \ctx }{ \vtype_2 }{ \vtype_1 }
\qquad
\subty{ \extendCtx{\ctx}{\declItem{\binder}{\vtype_2}} }{ \vtype_3 }{ \vtype_4 }
}{
\subty{ \ctx }{ \Pi{\binder:\vtype_1}{\vtype_2} }
{ \Pi{\binder:\vtype_3}{\vtype_4} }
}
\\[2em]
\rule{ST-RECORD-TYPE}{
\subty{ \ctx }{ \vtype_1 }{ \vtype_3 }
\qquad
\subty{ \extendCtx{\ctx}{\declItem{\binder}{\vtype_1}} }{ \vtype_2 }{ \vtype_4 }
}{
\subty{ \ctx }{ \RecordCons{\label \as \binder:\vtype_1}{\vtype_2} }
{ \RecordCons{\label \as \binder:\vtype_3}{\vtype_4} }
}
\\[2em]
\rule{ST-EMPTY-RECORD-TYPE}{}{
\subty{ \ctx }{ \RecordEmpty }{ \RecordEmpty }
}
\\[2em]
\rule{ST-ALPHA-EQ}{
\vtype_1 \equiv_{\alpha} \vtype_2
}{
\subty{ \ctx }{ \vtype_1 }{ \vtype_2 }
}
\\[2em]
\end{array}
\]</p>
<a class="header" href="#universe-shifting" id="universe-shifting"><h3>Universe shifting</h3></a>
<p>We implement explicit level shifts, giving us something like what Conor McBride
describes in his blog post, <a href="https://pigworker.wordpress.com/2015/01/09/universe-hierarchies/">universe hierarchies</a>.</p>
<p>We define \(\shift(-,-)\) for values:</p>
<p>\[
\begin{array}{llrl}
\shift(\var{i},                                             &amp; j) &amp; = &amp; \var{i} \\
\shift(\app{\nexpr}{\texpr},                                &amp; j) &amp; = &amp; \app{\shift(\nexpr, j)}{\shift(\texpr, j)} \\
\shift(\case{\nexpr}{\overline{\tpat_i \rightarrow \texpr_i}^{;}}, &amp; j) &amp; = &amp;
% FIXME: define pattern shifting
\case{\shift(\nexpr, j)}{\overline{\shift(\tpat_i, j) \rightarrow \shift(\texpr_i, j)}^{;}} \\
\shift(\nexpr.\label,                                       &amp; j) &amp; = &amp; \shift(\nexpr, j).\label \\
\shift(\Type{i},                                            &amp; j) &amp; = &amp; \Type{i + j} \\
\shift(\Pi{\binder:\vtype_1}{\vtype_2},                     &amp; j) &amp; = &amp; \Pi{\binder:\shift(\vtype_1, j)}{\shift(\vtype_2, j)} \\
\shift(\lam{\binder:\vtype}{\vexpr},                        &amp; j) &amp; = &amp; \lam{\binder:\shift(\vtype, j)}{\shift(\vexpr, j)} \\
\shift(\RecordCons{\label \as \binder:\vtype_1}{\vtype_2},  &amp; j) &amp; = &amp; \RecordCons{\label \as \binder:\shift(\vtype_1, j)}{\shift(\vtype_2, j)} \\
\shift(\RecordEmpty,                                        &amp; j) &amp; = &amp; \RecordEmpty \\
\shift(\record{\label=\vexpr_1, \vexpr_2},                  &amp; j) &amp; = &amp; \record{\label=\shift(\vexpr_1, j), \shift(\vexpr_2, j)} \\
\shift(\record{},                                           &amp; j) &amp; = &amp; \record{} \\
\\[2em]
\end{array}
\]</p>
<blockquote>
<p><strong>NOTE</strong>:
We might want to investigate making this shifting operator more expressive and
'first class', perhaps as was described in <a href="http://www-sop.inria.fr/members/Damien.Rouhling/data/internships/M1Report.pdf">Dependently typed lambda calculus
with a lifting operator</a>. For now this seems to be expressive
enough for most use cases that our users might run into.</p>
</blockquote>
<a class="header" href="#pattern-matching" id="pattern-matching"><h3>Pattern matching</h3></a>
<p>This judement takes an expression \(\wexpr\) in weak head normal form, and a
pattern \(\tpat\) and returns a substitution \(\theta\) with the matched bindings.</p>
<p>\[
\boxed{
\match{ \wexpr }{ \tpat }{ \theta }
}
\\[2em]
\begin{array}{cl}
\rule{M-VAR}{}{
\match{ \wexpr }{ \binder }{ [\binder \rightarrow \wexpr] }
}
\\[2em]
% TODO:
%   \rule{M-RECORD}{
%       \match{ \wexpr_1 }{ \tpat_1 }{ \theta_1 }
%       \qquad
%       \match{ \wexpr_2 }{ \tpat_2 }{ \theta_2 }
%   }{
%       \match{ \record{\label=\wexpr_1, \wexpr_2} }{ \record{\label=\tpat_1, \tpat_2} }{ \theta_1 \doubleplus \theta_2 }
%   }
%   \\[2em]
%   \rule{M-EMPTY-RECORD}{}{
%       \match{ \record{} }{ \record{} }{ [] }
%   }
%   \\[2em]
\end{array}
\]</p>
<a class="header" href="#type-checking-of-patterns" id="type-checking-of-patterns"><h3>Type checking of patterns</h3></a>
<p>\[
\boxed{
\checkpat{ \ctx }{ \rpat }{ \vtype }{ \tpat }{ \ctx' }
}
\\[2em]
\begin{array}{cl}
\rule{CP-BINDER}{}{
\checkpat{ \ctx }{ \binder }{ \vtype }{ \binder }{ \binder : \vtype }
}
\\[2em]
\rule{CP-CONV}{
\inferpat{ \ctx }{ \rpat }{ \vtype_2 }{ \tpat }{ \ctx' }
\qquad
\subty{ \ctx }{ \vtype_1 }{ \vtype_2 }
}{
\checkpat{ \ctx }{ \rpat }{ \vtype_1 }{ \tpat }{ \ctx' }
}
\\[2em]
\end{array}
\]</p>
<a class="header" href="#type-inference-of-patterns" id="type-inference-of-patterns"><h3>Type inference of patterns</h3></a>
<p>\[
\boxed{
\inferpat{ \ctx }{ \rpat }{ \vtype }{ \tpat }{ \ctx' }
}
\\[2em]
\begin{array}{cl}
\rule{IP-ANN}{
\infer{ \ctx }{ \rtype }{ \Type{i} }{ \ttype }
\qquad
\eval{ \ctx }{ \ttype }{ \vtype }
\qquad
\checkpat{ \ctx }{ \rpat }{ \vtype }{ \rpat }{ \ctx' }
}{
\inferpat{ \ctx }{ \rpat : \rtype }{ \rtype }{ \rpat : \rtype }{ \ctx' }
}
\\[2em]
\end{array}
\]</p>
<blockquote>
<p><strong>TODO:</strong></p>
<ul>
<li>Pattern matching coverage checking</li>
<li>Ensure that parametericity is maintained. Should we forbid <a href="https://stackoverflow.com/questions/45439486/pattern-matching-on-type-in-idris">pattern matching
directly on types</a>? McBride seems to <a href="https://stackoverflow.com/questions/23220884/why-is-typecase-a-bad-thing/26012264#26012264">think we can have our
cake and eat it</a>!</li>
</ul>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../appendix/design.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../appendix/influences.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../appendix/design.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../appendix/influences.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
