<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pikelet Language Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for the Pikelet Language">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="index.html">Pikelet</a></li><li><a href="installation/index.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li><a href="language/index.html"><strong aria-hidden="true">2.</strong> Language</a></li><li><ol class="section"><li><a href="language/conditionals.html"><strong aria-hidden="true">2.1.</strong> Conditionals</a></li><li><a href="language/records.html"><strong aria-hidden="true">2.2.</strong> Records</a></li><li><a href="language/functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li><a href="language/type-inference.html"><strong aria-hidden="true">2.4.</strong> Type inference</a></li><li><a href="language/types-of-types.html"><strong aria-hidden="true">2.5.</strong> Types of types</a></li></ol></li><li><a href="appendix/index.html"><strong aria-hidden="true">3.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix/design.html"><strong aria-hidden="true">3.1.</strong> Design</a></li><li><a href="appendix/theory.html"><strong aria-hidden="true">3.2.</strong> Theory</a></li><li><a href="appendix/implementation.html"><strong aria-hidden="true">3.3.</strong> Implementation</a></li><li><a href="appendix/influences.html"><strong aria-hidden="true">3.4.</strong> Influences</a></li><li><a href="appendix/references.html"><strong aria-hidden="true">3.5.</strong> References</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Pikelet Language Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#pikelet-" id="pikelet-"><h1>Pikelet 🥞</h1></a>
<p>Pikelet is a small <a href="https://en.wikipedia.org/wiki/Dependent_type">dependently typed</a> language. It
doesn't do many interesting things yet, but hopefully that will change in the future!</p>
<ul>
<li><a href="https://github.com/pikelet-lang/pikelet">Source code</a></li>
<li><a href="https://github.com/pikelet-lang/pikelet/issues">Issues</a></li>
<li><a href="https://gitter.im/pikelet-lang/Lobby">Gitter Chat</a></li>
</ul>
<a class="header" href="#a-small-taste" id="a-small-taste"><h2>A small taste</h2></a>
<p>Definitions:</p>
<pre><code class="language-pikelet">module prelude;

id : (a : Type) -&gt; a -&gt; a;
id a x = x;

const : (a b : Type) -&gt; a -&gt; b -&gt; a;
const a b x y = x;
</code></pre>
<p>Interactive REPL:</p>
<pre><code class="language-pikelet-repl">$ cargo run repl
    ____  _ __        __     __
   / __ \(_) /_____  / /__  / /_
  / /_/ / / //_/ _ \/ / _ \/ __/    Version 0.1.0
 / ____/ / ,&lt; /  __/ /  __/ /_      https://github.com/pikelet-lang/pikelet
/_/   /_/_/|_|\___/_/\___/\__/      :? for help

Pikelet&gt; (\(a : Type) (x : a) =&gt; x) String &quot;hello&quot;
&quot;hello&quot; : String
Pikelet&gt; :t Type
Type 1
Pikelet&gt; 1 : I16
1 : I16
Pikelet&gt;
</code></pre>
<a class="header" href="#what-is-a-pikelet" id="what-is-a-pikelet"><h2>What is a Pikelet?</h2></a>
<p>A pikelet is an odd sort of small (often pre-made) pancake found in Australia
and New Zealand. Commonly sent in school lunches spread with jam and butter.
Handily it also has a name that includes 'pi' and 'let' as substrings! 😅</p>
<a class="header" href="#installation" id="installation"><h1>Installation</h1></a>
<p>Pikelet is written in <a href="https://www.rust-lang.org/">Rust</a> and therefore needs to be compiled with
Cargo, because we don't yet offer prebuilt binaries. If you haven't already
installed Rust, please <a href="https://www.rust-lang.org/downloads.html">install it</a> now!</p>
<a class="header" href="#cloning-the-source-from-github" id="cloning-the-source-from-github"><h2>Cloning the source from Github</h2></a>
<p>We've not yet published Pikelet on <a href="https://crates.io/">crates.io</a>, so you'll first need
to clone <a href="https://github.com/pikelet-lang/pikelet">the repository</a> using git:</p>
<pre><code class="language-sh">git clone https://github.com/pikelet-lang/pikelet.git
cd pikelet
</code></pre>
<a class="header" href="#running-the-repl" id="running-the-repl"><h2>Running the REPL</h2></a>
<p>After cloning, you can now run the <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> using Cargo:</p>
<pre><code class="language-sh">cargo run repl
</code></pre>
<p>You will now need to wait for Cargo to download and build the dependencies, but
sooner or later the REPL will be ready for you to interact with!</p>
<a class="header" href="#language" id="language"><h1>Language</h1></a>
<a class="header" href="#contents" id="contents"><h2>Contents</h2></a>
<ul>
<li><a href="#declarations">Declarations</a></li>
<li><a href="#comments">Comments</a></li>
<li><a href="#primitive-types-and-their-literals">Primitive types and their literals</a></li>
<li><a href="#type-annotations">Type annotations</a></li>
<li><a href="#identifiers">Identifiers</a></li>
</ul>
<a class="header" href="#declarations" id="declarations"><h2>Declarations</h2></a>
<p>Declarations are preceded by a type annotation, and followed by a definition:</p>
<pre><code class="language-pikelet">greeting : String;
greeting = &quot;hello there!&quot;;
</code></pre>
<p>We can also make type aliases in the same way:</p>
<pre><code class="language-pikelet">name : Type;
name = String;
</code></pre>
<a class="header" href="#comments" id="comments"><h2>Comments</h2></a>
<p>Line comments are preceded by a double dash:</p>
<pre><code class="language-pikelet">-- this is a comment!
</code></pre>
<p>Doc comments are preceded by a triple pipe, and are used to document
definitions:</p>
<pre><code class="language-pikelet">||| This is a documented definition
|||
||| # Example
|||
||| ```pikelet-repl
||| Pikelet&gt; self-aware-string
||| &quot;I am a string!&quot; : String
||| ```
self-aware-string : String;
self-aware-string = &quot;I am a string!&quot;;
</code></pre>
<a class="header" href="#primitive-types-and-their-literals" id="primitive-types-and-their-literals"><h2>Primitive types and their literals</h2></a>
<p>Pikelet has a number of primitive types:</p>
<table><thead><tr><th> Type     </th><th> Literal                                </th></tr></thead><tbody>
<tr><td> <code>Bool</code>   </td><td> <code>true</code>, <code>false</code>                        </td></tr>
<tr><td> <code>String</code> </td><td> <code>&quot;hello there!&quot;</code>                       </td></tr>
<tr><td> <code>Char</code>   </td><td> <code>'a'</code>, <code>'b'</code>, ..., <code>'\n'</code>, <code>'\t'</code>, ... </td></tr>
<tr><td> <code>U8</code>     </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>U16</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>U32</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>U64</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>I8</code>     </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>I16</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>I32</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>I64</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ...                     </td></tr>
<tr><td> <code>F32</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ..., <code>0.0</code>, <code>1.0</code>, ...  </td></tr>
<tr><td> <code>F64</code>    </td><td> <code>1</code>, <code>2</code>, <code>3</code>, ..., <code>0.0</code>, <code>1.0</code>, ...  </td></tr>
</tbody></table>
<blockquote>
<p><strong>Note:</strong> You can't do much with these primitive types yet. In the future we
will add some primitive functions to allow you to manipulate them.</p>
</blockquote>
<a class="header" href="#type-annotations" id="type-annotations"><h2>Type annotations</h2></a>
<p>If you note <a href="#primitive-types-and-their-literals">above</a>, a number of the
primitive types share a literal representation. Pikelet will try to predictably
infer the types, but if it fails to do so you will get an error. In that case
you can use the type annotation operator, <code>(:)</code>, to specify the intended type:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; 1
error: ambiguous integer literal
Pikelet&gt; 1 : I32
1 : I32
Pikelet&gt; 1 : F32
1 : F32
Pikelet&gt; 1.0 : F32
1.0 : F32
Pikelet&gt; 1.1 : U64
error: found a floating point literal, but expected a type `U64`
- &lt;repl&gt;:1:1
1 | 1.1 : U64
  | ^^^ the literal
</code></pre>
<a class="header" href="#identifiers" id="identifiers"><h2>Identifiers</h2></a>
<blockquote>
<p>TODO</p>
</blockquote>
<a class="header" href="#conditionals" id="conditionals"><h1>Conditionals</h1></a>
<a class="header" href="#if-then-else-expressions" id="if-then-else-expressions"><h2>If-then-else expressions</h2></a>
<p><code>if</code> expressions take an expression that evaluates to a <code>Bool</code> (the <em>condition</em>),
and two other expressions (the <em>consequent</em> and the <em>alternative</em>) that evaluate
to the same type. If the condition evaluates to <code>true</code>, then the consequent will
be evaluated and returned, otherwise the alternative will be evaluated and
returned.</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; if true then &quot;hello!&quot; else &quot;goodbye!&quot;
&quot;hello!&quot; : String
Pikelet&gt; if false then &quot;hello!&quot; else &quot;goodbye!&quot;
&quot;goodbye!&quot; : String
</code></pre>
<a class="header" href="#case-expressions" id="case-expressions"><h2>Case expressions</h2></a>
<p>Pikelet supports case expressions on strings, and numbers:</p>
<pre><code class="language-pikelet">case value of {
    &quot;hello&quot; =&gt; &quot;goodbye&quot;;
    &quot;goodbye&quot; =&gt; &quot;hello&quot;;
    value =&gt; value; -- matches all strings
}
</code></pre>
<p>Note that we don't (yet) check that the series of patterns provided cover all
possible cases, leading to the following embarrassing error:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; case &quot;hello&quot; of { &quot;hi&quot; =&gt; &quot;oh dear&quot; }
error: internal compiler error: no patterns matched the given expression
</code></pre>
<p>In the future we' plan to fix this, add support for matching on booleans, and
also support more complex patterns (eg. for records).</p>
<a class="header" href="#records" id="records"><h1>Records</h1></a>
<a class="header" href="#contents-1" id="contents-1"><h2>Contents</h2></a>
<ul>
<li><a href="#record-values-and-record-types">Record values and record types</a></li>
<li><a href="#field-lookups">Field lookups</a></li>
<li><a href="#dependent-record-types">Dependent record types</a></li>
</ul>
<a class="header" href="#record-values-and-record-types" id="record-values-and-record-types"><h2>Record values and record types</h2></a>
<p>You can group together multiple values by using records:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; record { x = 3.0 : F32; y = 3.0 : F32 }
record { x = 3; y = 3 } : Record { x : F32; y : F32 }
</code></pre>
<p>Take note of the following:</p>
<ul>
<li>record values use the lower case <code>record</code> keyword</li>
<li>record types use the upper case <code>Record</code> keyword</li>
<li>we have to <a href="#type-annotations">annotate</a> ambiguous field values</li>
</ul>
<p>We can make a new definition for point types:</p>
<pre><code class="language-pikelet">Point2d = Record {
  x : F32;
  y : F32;
};
</code></pre>
<p>You can then use this type to make it easier to define a point record:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; record { x = 3.0; y = 3.0 } : Point2d
record { x = 3; y = 3 } : Record { x : F32; y : F32 }
</code></pre>
<p>Note that we no longer need to annotate each field! Pikelet was able to pick up
the type of each field from the type definition during type checking. You can
read more about Pikelet's type inference on <a href="./type-inference">the type inference page</a>.</p>
<a class="header" href="#field-lookups" id="field-lookups"><h2>Field lookups</h2></a>
<p>You can access the value associated with a field by using the dot operator:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; record { name = &quot;Jane&quot; }.name
&quot;Jane&quot; : String
</code></pre>
<a class="header" href="#dependent-record-types" id="dependent-record-types"><h2>Dependent record types</h2></a>
<p>Field types can depend on data from previous fields. Here we turn a
fixed-length array into a dynamically sized array, by using the <code>len</code> field
later on to define the <code>data</code> field's annotation:</p>
<pre><code class="language-pikelet">DArray (a : Type) = Record {
    len : I32;
    data : Box (Array len a);
};
</code></pre>
<a class="header" href="#functions" id="functions"><h1>Functions</h1></a>
<a class="header" href="#contents-2" id="contents-2"><h2>Contents</h2></a>
<ul>
<li><a href="#simply-typed-functions">Simply typed functions</a></li>
<li><a href="#polymorphic-functions">Polymorphic functions</a></li>
<li><a href="#syntactic-sugar-for-functions">Syntactic sugar for functions</a></li>
</ul>
<a class="header" href="#simply-typed-functions" id="simply-typed-functions"><h2>Simply typed functions</h2></a>
<p>Here are some simple functions and their types:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; :t \x : I32 =&gt; x
I32 -&gt; I32
Pikelet&gt; :t \x : String =&gt; x
String -&gt; String
Pikelet&gt; :t \x : Char =&gt; x
Char -&gt; Char
</code></pre>
<p>Note that all of these types follow the same pattern - they are the identity
function! This means that if you pass a value to them, they'll return the same
thing without alteration!</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; (\x : I32 =&gt; x) 42
42 : I32
Pikelet&gt; (\x : String =&gt; x) &quot;hi&quot;
&quot;hi&quot; : String
Pikelet&gt; (\x : Char =&gt; x) 'b'
'b' : Char
</code></pre>
<a class="header" href="#polymorphic-functions" id="polymorphic-functions"><h2>Polymorphic functions</h2></a>
<p>Alas, we can't reuse one of these identity functions with other, incompatible
types:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; (\x : I32 =&gt; x) 4.0
error: found a floating point literal, but expected a type `I32`
- &lt;repl&gt;:1:17
1 | (\x : I32 =&gt; x) 4.0
  |                 ^^^ the literal
</code></pre>
<p>Let's make this identity function polymorphic by adding a parameter for the type
of the argument:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; :t \(a : Type) (x : a) =&gt; x
(a : Type) -&gt; a -&gt; a
</code></pre>
<p>We now have a polymorphic identity function! We can specialize this function by
applying a type to it:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; (\(x : Type) (x : a) =&gt; x) String &quot;hello&quot;
&quot;hello&quot; : String
Pikelet&gt; (\(x : Type) (x : a) =&gt; x) I32 1
1 : I32
</code></pre>
<a class="header" href="#syntactic-sugar-for-functions" id="syntactic-sugar-for-functions"><h2>Syntactic sugar for functions</h2></a>
<p>In Pikelet, all functions take a single argument - in order to pass multiple
arguments we use currying. The following functions are equivalent:</p>
<pre><code class="language-pikelet">\(x : Type) (x : a) =&gt; x
\(x : Type) =&gt; \(x : a) =&gt; x
</code></pre>
<p>Non-dependent functions can be expressed without explicit parameter names. For
example the following function types are equivalent:</p>
<pre><code class="language-pikelet">(a : Type) (x : a) -&gt; a
(a : Type) -&gt; (x : a) -&gt; a
(a : Type) -&gt; a -&gt; a
</code></pre>
<a class="header" href="#type-inference" id="type-inference"><h1>Type inference</h1></a>
<p>Many statically typed languages perform type inference to varying degrees, and
Pikelet is no different! The goal is to reduce the burden of writing type
annotations everywhere. Some languages like <a href="https://ocaml.org/">OCaml</a> and
<a href="http://elm-lang.org/">Elm</a> can even infer the types of a whole program without
any annotations at all!</p>
<p>Pikelet's type inference follows some very simple rules that you can probably
pick up on your own, but we thought it might help to give a deeper explanation
of how it works, without getting too bogged down in the theoretical details.</p>
<a class="header" href="#contents-3" id="contents-3"><h2>Contents</h2></a>
<ul>
<li><a href="#bidirectional-typechecking">Bidirectional type checking</a>
<ul>
<li><a href="#inferable-terms">Inferable terms</a></li>
<li><a href="#checkable-terms">Checkable terms</a></li>
</ul>
</li>
<li><a href="#further-reading">Further reading</a></li>
</ul>
<a class="header" href="#bidirectional-type-checking" id="bidirectional-type-checking"><h2>Bidirectional type checking</h2></a>
<p>Pikelet has a rather flexible type system that can have expressions embedded in
them, so we've opted to use an algorithm known as 'bidirectional type checking'
as a way to get a decent amount of inference while still remaining relatively
predictable to you, the programmer. This means that you may sometimes have to
write annotations on top-level definitions, but the types should propagate
downwards and inner definitions should not require much annotation at all.</p>
<p>To do this we break the terms of the language into two groups. We call these
<a href="#inferable-terms"><em>inferable terms</em></a> and <a href="#checkable-terms"><em>checkable terms</em></a>.</p>
<a class="header" href="#inferable-terms" id="inferable-terms"><h3>Inferable terms</h3></a>
<p>Inferable terms can be checked on their own or based on previous definitions.</p>
<blockquote>
<p>TODO: Explain examples</p>
</blockquote>
<pre><code class="language-pikelet-repl">Pikelet&gt; true
Pikelet&gt; &quot;1&quot;
Pikelet&gt; 'a'
Pikelet&gt; Bool
Pikelet&gt; Type
Pikelet&gt; Type 2
Pikelet&gt; record { name = &quot;Jane&quot; }
Pikelet&gt; Record { name : String }
Pikelet&gt; record { x = 3.0 : F32; y = 3.0 : F32 }
Pikelet&gt; \x : Int =&gt; x
Pikelet&gt; (a : Type) -&gt; a
</code></pre>
<a class="header" href="#checkable-terms" id="checkable-terms"><h3>Checkable terms</h3></a>
<p>Checkable terms need extra annotations, or be used in a position where extra
information can be supplied.</p>
<blockquote>
<p>TODO: Explain examples</p>
</blockquote>
<pre><code class="language-pikelet-repl">Pikelet&gt; 1
Pikelet&gt; 2.0
Pikelet&gt; record { x = 3.0; y = 3.0 }
Pikelet&gt; \x =&gt; x
</code></pre>
<pre><code class="language-pikelet-repl">Pikelet&gt; 1 : I32
Pikelet&gt; 2.0 : F32
Pikelet&gt; record { x = 3.0; y = 3.0 } : Record { x : F32; y : F32 }
Pikelet&gt; \x =&gt; x : I32 -&gt; I32
</code></pre>
<a class="header" href="#further-reading" id="further-reading"><h2>Further reading</h2></a>
<p>We describe Pikelet's type checking algorithm more formally
<a href="./appendix/theory">in the appendix</a>. If you have a background in programming
languages and type theory this might be of interest to you. If not, that's
ok - understanding the formal notation is not necessary for developing a high
level intuition of type inference in Pikelet.</p>
<a class="header" href="#types-of-types" id="types-of-types"><h1>Types of types</h1></a>
<p>Types also have types!</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; :t I32
Type
</code></pre>
<p>You might then ask, “what is the type of <code>Type</code>?”</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; :t Type
Type 1
</code></pre>
<p>Note that <code>Type</code> is actually just syntactic sugar for <code>Type 0</code>:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; :t Type 0
Type 1
</code></pre>
<p>In fact, Pikelet has an infinite number of 'universes', each one 'bigger' than the
previous:</p>
<pre><code class="language-pikelet-repl">Pikelet&gt; :t Type 0
Type 1
Pikelet&gt; :t Type 1
Type 2
Pikelet&gt; :t Type 2
Type 3
...
</code></pre>
<p>You can think of these as larger and larger sets, with the smaller type
universes being contained within the larger type universes:</p>
<blockquote>
<p>TODO: Put a nice SVG diagram of the sets of types here</p>
<pre><code>(Type 2
  (Type 1
    (Type 0
      (I32, F32, String,
        (1, 4.0, &quot;hello&quot;)))))
</code></pre>
</blockquote>
<a class="header" href="#appendix" id="appendix"><h1>Appendix</h1></a>
<p>Here you will find additional reference information for understanding the
theoretical foundations behind Pikelet.</p>
<a class="header" href="#design" id="design"><h1>Design</h1></a>
<a class="header" href="#design-goals" id="design-goals"><h2>Design goals</h2></a>
<p>Pikelet should feel:</p>
<ul>
<li>Friendly</li>
<li>Liberating</li>
<li>Sympathetic</li>
</ul>
<p>This is a rough list of things that might be interesting to explore with Pikelet:</p>
<ul>
<li>Sympathetic to humans
<ul>
<li>Programs should look pretty, and read clearly</li>
<li>Friendly community</li>
<li>Helpful interactive tooling</li>
<li>Tight feedback loops</li>
</ul>
</li>
<li>Sympathetic to machines
<ul>
<li>Predictable performance</li>
<li>Predictable memory layout</li>
<li>Predictable optimizations</li>
<li>Zero (or close to zero) cost abstractions</li>
<li>Low level control</li>
<li>Minimal runtime</li>
</ul>
</li>
<li>Sympathetic to real-world realities
<ul>
<li>Gradual correctness (eg. examples -&gt; generative tests -&gt; solvers -&gt; proofs)</li>
<li>Provide clearly marked escape hatches (learn from the lessons of <a href="rust-belt">RustBelt</a>?)</li>
<li>Automatic upgrades of code - between language and library versions</li>
<li>Work for large scale systems</li>
</ul>
</li>
<li>Sympathetic to mathematical foundations
<ul>
<li>Simple core language that can be formalized and proven sound</li>
<li>Should allow for mathematically inspired patterns of code reuse</li>
<li>Allow newcomers to learn mathematical thinking gradually</li>
<li>Adaptable to future developments in type theory</li>
</ul>
</li>
</ul>
<p>It's unclear how many of these will be able to be met, and what priorities these
should have, so this list might change over time. Come and <a href="https://gitter.im/pikelet-lang/Lobby">chat with us</a>
if you'd like to give your input and get involved!</p>
<a class="header" href="#some-key-features-of-interest" id="some-key-features-of-interest"><h2>Some key features of interest</h2></a>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Dependent_type">Dependent types</a></li>
<li><a href="https://en.wikipedia.org/wiki/Pure_function">Purely functional</a></li>
<li><a href="https://en.wikipedia.org/wiki/Eager_evaluation">Strict evaluation</a></li>
<li>Implicit arguments</li>
<li>Dependent records+instance arguments as first class modules/type classes</li>
<li>Non-uniform memory layout</li>
<li><a href="https://bentnib.org/quantitative-type-theory.pdf">Quantitative type theory</a>
for <a href="https://en.wikipedia.org/wiki/Type_erasure">erasure</a> and
<a href="https://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems">linear types</a></li>
<li>Totality checking</li>
<li>Explicit tail-call elimination</li>
<li>Interactive program development using holes</li>
</ul>
<p>Some more hand-wavey ideas:</p>
<ul>
<li>Monomorphization by partial-evaluation of instance arguments</li>
<li>Optional/configurable garbage collection</li>
<li>Alternatives to currying for function application?</li>
<li>First-class declarations (Levitation or Elaborator Reflection could be useful here)</li>
</ul>
<p>Some other features that may be trickier to integrate given the previous
features and design goals:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Effect_system">Effect systems/Algebraic Effects</a>
<ul>
<li>could make it easier to integrate async-io without needing to build it in</li>
<li>how do cubical type theory and observational type theory play into this?</li>
<li>how do we makes this <em>fast</em> for systems programming?
<ul>
<li>should compile down in a similar way to the equivalent procedural code in Rust or C</li>
<li>most systems cause lots of intermediate allocations or stack switching</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.cs.kent.ac.uk/people/staff/dao7/publ/combining-effects-and-coeffects-icfp16.pdf">Combined Effects/Coeffects</a>
<ul>
<li>allow for statically checked compilation configurations</li>
<li>explicit variable capture could be modelled as a coeffect</li>
<li>could subsume quantitative type theory, implicit arguments, etc</li>
<li>not yet integrated into dependent types in the research literature</li>
</ul>
</li>
<li>Row polymorphism
<ul>
<li>no research on integrating these with dependent records and inductive data types</li>
</ul>
</li>
<li>Program composition via category theory
<ul>
<li>Challenging to integrate in the presence of strict evaluation</li>
<li>Similar problems to effect systems: we don't want to allocate intermediate
data structures, instead we want to build up stack allocated state machines
(like in Rust's future and iterator traits) to be executed later</li>
</ul>
</li>
</ul>
<a class="header" href="#a-possible-implementation-plan" id="a-possible-implementation-plan"><h2>A possible implementation plan</h2></a>
<ol>
<li>Start with a simple dependent type system, like <a href="https://www.andres-loeh.de/LambdaPi/">LambdaPi</a></li>
<li>Implement additional language extensions needed for actual usefulness
<ul>
<li>dependent records</li>
<li>let/where bindings</li>
<li>quantitative type theory</li>
<li>implicit arguments</li>
<li>instance arguments</li>
<li>better universe handling (or a flag to turn on <code>Type : Type</code> in the interim)</li>
</ul>
</li>
<li>Implement back end(s)
<ul>
<li>JIT and embeddable runtime (for bootstrapping usage) - possibly with
<a href="https://github.com/nbp/holyjit">HolyJIT</a>?</li>
<li>Optimizing compiler - Possibly with LLVM or <a href="https://github.com/Cretonne/cretonne">Cretonne</a>,
or a verified compiler (like CompCert) in the future
<ul>
<li>Cretonne would unlock WebASM, which would be a huge boost</li>
<li>Figure out how to integrate with libraries written in other languages,
like C or Rust</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>By starting with a JIT we could get initial usage from embedding the language
within existing Rust programs, like games. Looking into the future it would also
be nice to then move forward towards implementing a native compiler, however.</p>
<p>At the moment we are building the language in Rust, but perhaps it would be
better to build a verified implementation in Coq/Agda/Lean/Idris/something else.
That way we can actually start proving some of the claims we desire to make
about our system. A concern could be that we go too far down the route of
implementation and it would be extremely challenging to then form a solid
specification for what we are building. On the other hand, as always, the
downside of a verified implementation is that it could take a prohibitive
amount of time to complete.</p>
<a class="header" href="#theory" id="theory"><h1>Theory</h1></a>
<p>A formalization of the semantics for type checking and normalizing Pikelet.</p>
<a class="header" href="#contents-4" id="contents-4"><h2>Contents</h2></a>
<ul>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#notation">Notation</a></li>
<li><a href="#where-is-the-soundness-proof">Where is the soundness proof?</a></li>
</ul>
</li>
<li><a href="#syntax">Syntax</a>
<ul>
<li><a href="#raw-terms">Raw terms</a></li>
<li><a href="#terms">Terms</a></li>
<li><a href="#values">Values</a></li>
<li><a href="#contexts">Contexts</a></li>
</ul>
</li>
<li><a href="#semantics">Semantics</a>
<ul>
<li><a href="#elaboration">Elaboration</a></li>
<li><a href="#normalization">Normalization</a></li>
<li><a href="#type-checking">Type checking</a></li>
<li><a href="#type-inference">Type inference</a></li>
<li><a href="#pattern-matching">Pattern matching</a></li>
<li><a href="#type-checking-of-patterns">Type checking of patterns</a></li>
<li><a href="#type-inference-of-patterns">Type inference of patterns</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction" id="introduction"><h2>Introduction</h2></a>
<p>At its core, Pikelet is a dependently typed lambda calculus with a stratified
universe hierarchy.</p>
<blockquote>
<p><strong>Note:</strong>
This document is intended for those who are interested in looking deeper into the formal foundations of Pikelet.
You <em>don't</em> need to understand this for general use of Pikelet, so feel free to skip this document if that is easier.
We will however make an effort to explain some of the notation we use here, and point to resources that might help if this piques your curiosity!</p>
</blockquote>
<a class="header" href="#notation" id="notation"><h3>Notation</h3></a>
<p>We use a combination of some <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a>-style syntax definitions with
<a href="natural-deduction">natural deduction</a> rules to define our language. This
combination of notation is sometimes referred to as <em>computer science
metanotation</em> and is, alas, a little hard to pin down <a href="https://www.youtube.com/watch?v=7HKbjYqqPPQ">as conventions vary</a>
between papers and authors. The general rules stay the same however, and once
you learn to read them they are much more succinct than an actual implementation
could be, and are an invaluable tool for quickly getting a high-level overview
of a programming language's semantics.</p>
<blockquote>
<p><strong>TODO:</strong>
Describe BNF, natural deduction rules, overbars, variable binding, etc.</p>
</blockquote>
<p>Some handy links:</p>
<ul>
<li><a href="http://siek.blogspot.com.au/2012/07/crash-course-on-notation-in-programming.html">Crash Course on Notation in Programming Language Theory</a></li>
<li><a href="https://blog.acolyer.org/2018/01/26/a-practitioners-guide-to-reading-programming-languages-papers/">A practitioner’s guide to reading programming languages papers</a></li>
<li><a href="http://steshaw.org/plt/">A path to enlightenment in Programming Language Theory</a></li>
</ul>
<a class="header" href="#where-is-the-soundness-proof" id="where-is-the-soundness-proof"><h3>Where is the soundness proof?</h3></a>
<p>Here we are only defining the rules of our language's type checking and
evaluation. Further work needs to be done to verify that our system actually
satisfies certain interesting <a href="https://en.wikipedia.org/wiki/Type_safety">type soundness properties</a>,
like progress, preservation, <a href="https://en.wikipedia.org/wiki/Normalization_property_(abstract_rewriting)">strong normalization</a>,
etc. If you would like to discuss this with us, please check out
<a href="https://github.com/pikelet-lang/pikelet/issues/39">the relevant github issue</a>!</p>
<a class="header" href="#syntax" id="syntax"><h2>Syntax</h2></a>
<a class="header" href="#raw-terms" id="raw-terms"><h3>Raw terms</h3></a>
<p>\[
% Haskell-style append https://tex.stackexchange.com/questions/4194/how-to-typeset-haskell-operator-and-friends
\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
% Small caps https://github.com/mathjax/MathJax-docs/wiki/Small-caps-%5Ctextsc-in-MathJaxx
\def\sc#1{\dosc#1\csod}
\def\dosc#1#2\csod{{\rm #1{\small #2}}}
\
\newcommand{\rule}[3]{ \dfrac{ ~~#2~~ }{ ~~#3~~ } &amp; \Tiny{\text{(#1)}} }
\
\DeclareMathOperator{\max}{max}
\DeclareMathOperator{\field}{field}
\DeclareMathOperator{\fieldty}{fieldty}
\DeclareMathOperator{\fieldsubst}{fieldsubst}
\DeclareMathOperator{\Match}{\sc{MATCH}}
\
% Judgments
\newcommand{\eval}[3]{ #1 \vdash #2 \Rightarrow #3 }
\newcommand{\check}[4]{ #1 \vdash #2 \uparrow #3 \leadsto #4 }
\newcommand{\infer}[4]{ #1 \vdash #2 \downarrow #3 \leadsto #4 }
\newcommand{\match}[3]{ \Match(#1,#2) \Longrightarrow #3 }
\newcommand{\checkpat}[5]{ #1 \vdash #2 \uparrow #3 \leadsto #4 \Longrightarrow #5 }
\newcommand{\inferpat}[5]{ #1 \vdash #2 \downarrow #3 \leadsto #4 \Longrightarrow #5 }
\
% Metavariables
\newcommand{\rexpr}{r} % raw expressions
\newcommand{\rtype}{R} % raw types
\newcommand{\rpat}{s}  % raw patterns
\
\newcommand{\texpr}{t} % expressions
\newcommand{\ttype}{T} % types
\newcommand{\tpat}{p}  % patterns
\
\newcommand{\vexpr}{v} % value expressions
\newcommand{\vtype}{V} % value types
\newcommand{\wexpr}{w} % whnf expressions
\newcommand{\wtype}{W} % whnf types
\newcommand{\nexpr}{n} % neutral expressions
\newcommand{\ntype}{N} % neutral types
\
% Keywords
\newcommand{\kw}[1]{ \mathsf{#1} }
\
% Term and Type constructors
\newcommand{\Type}{\mathsf{Type}}
\newcommand{\Bool}{\mathsf{Bool}}
\newcommand{\true}{\mathsf{true}}
\newcommand{\false}{\mathsf{false}}
\newcommand{\Arrow}[2]{ #1 \rightarrow #2 }
\newcommand{\Pi}[2]{ \Arrow{(#1)}{#2} }
\newcommand{\lam}[2]{ \lambda #1 . #2 }
\newcommand{\app}[2]{ #1 ~ #2 }
\newcommand{\ifte}[3]{ \kw{if} ~ #1 ~ \kw{then} ~ #2 ~ \kw{else} ~ #3 }
\newcommand{\case}[2]{ \kw{case} ~ #1 \left\{ #2 \right\} }
\newcommand{\Record}[1]{ ( #1 ) }
\newcommand{\record}[1]{ \langle #1 \rangle }
\newcommand{\subst}[3]{ #1 ~ [#2 \rightarrow #3] }
\
\begin{array}{rrll}
\rexpr,\rtype   &amp; ::= &amp; x                                   &amp; \text{variables} \\
&amp;   | &amp; \Type_i                             &amp; \text{universe of types ($i \in \mathbb{N}$)} \\
&amp;   | &amp; ?                                   &amp; \text{holes} \\
&amp;   | &amp; \Bool                               &amp; \text{type of booleans} \\
&amp;   | &amp; \true ~|~ \false                    &amp; \text{boolean literals} \\
&amp;   | &amp; \rexpr : \rtype                     &amp; \text{term annotated with a type} \\
&amp;   | &amp; \Pi{x:\rtype_1}{\rtype_2}           &amp; \text{dependent function type} \\
&amp;   | &amp; \lam{x:\rtype}{\rexpr}              &amp; \text{functions} \\
&amp;   | &amp; \app{\rexpr_1}{\rexpr_2}            &amp; \text{function application} \\
&amp;   | &amp; \ifte{\rexpr_1}{\rexpr_2}{\rexpr_3} &amp; \text{if expressions} \\
&amp;   | &amp; \case{\rexpr}{\overline{\rpat_i \rightarrow \rexpr_i}^{;}}
&amp; \text{case expressions} \\
&amp;   | &amp; \Record{l:\rtype_1, \rtype_2}       &amp; \text{record type extension} \\
&amp;   | &amp; \Record{}                           &amp; \text{empty record type} \\
&amp;   | &amp; \record{l=\rexpr_1, \rexpr_2}       &amp; \text{record extension} \\
&amp;   | &amp; \record{}                           &amp; \text{empty record} \\
&amp;   | &amp; \rexpr.l                            &amp; \text{record projection} \\
\\
\rpat           &amp; ::= &amp; x                                   &amp; \text{binder pattern} \\
&amp;   | &amp; \rpat : \rtype                      &amp; \text{pattern annotated with a type} \\
&amp;   | &amp; \true ~|~ \false                    &amp; \text{boolean literal patterns} \\
%   &amp;   | &amp; \record{l=\rpat_1, \rpat_2}         &amp; \text{record extension pattern} \\
%   &amp;   | &amp; \record{}                           &amp; \text{empty record pattern} \\
\\
\end{array}
\]</p>
<p>\[
\begin{array}{lrll}
\Arrow{\rtype_1}{\rtype_2} &amp; := &amp; \Pi{x:\rtype_1}{\rtype_2} &amp; \text{non-dependent function types} \\
\lam{x}{\rexpr}            &amp; := &amp; \lam{x:?}{\rexpr}         &amp; \text{functions (without an annotation)} \\
\end{array}
\]</p>
<a class="header" href="#terms" id="terms"><h3>Terms</h3></a>
<p>The core term syntax skips holes, ensuring that everything is fully elaborated:</p>
<p>\[
\begin{array}{rrll}
\texpr,\ttype   &amp; ::= &amp; x                                   &amp; \text{variables} \\
&amp;   | &amp; \Type_i                             &amp; \text{universe of types ($i \in \mathbb{N}$)} \\
&amp;   | &amp; \Bool                               &amp; \text{type of booleans} \\
&amp;   | &amp; \true ~|~ \false                    &amp; \text{boolean literals} \\
&amp;   | &amp; \texpr : \ttype                     &amp; \text{term annotated with a type} \\
&amp;   | &amp; \Pi{x:\ttype_1}{\ttype_2}           &amp; \text{dependent function type} \\
&amp;   | &amp; \lam{x:\ttype}{\texpr}              &amp; \text{functions} \\
&amp;   | &amp; \app{\texpr_1}{\texpr_2}            &amp; \text{function application} \\
&amp;   | &amp; \ifte{\texpr_1}{\texpr_2}{\texpr_3} &amp; \text{if expressions} \\
&amp;   | &amp; \case{\texpr}{\overline{\tpat_i \rightarrow \texpr_i}^{;}}
&amp; \text{case expressions} \\
&amp;   | &amp; \Record{l:\ttype_1, \ttype_2}       &amp; \text{record type extension} \\
&amp;   | &amp; \Record{}                           &amp; \text{empty record type} \\
&amp;   | &amp; \record{l=\texpr_1, \texpr_2}       &amp; \text{record extension} \\
&amp;   | &amp; \record{}                           &amp; \text{empty record} \\
&amp;   | &amp; \texpr.l                            &amp; \text{record projection} \\
\\
\tpat           &amp; ::= &amp; x                                   &amp; \text{binder pattern} \\
&amp;   | &amp; \tpat : \ttype                      &amp; \text{pattern annotated with a type} \\
&amp;   | &amp; \true ~|~ \false                    &amp; \text{boolean literal patterns} \\
&amp;   | &amp; \record{l=\tpat_1, \tpat_2}         &amp; \text{record extension pattern} \\
&amp;   | &amp; \record{}                           &amp; \text{empty record pattern} \\
\\
\end{array}
\]</p>
<a class="header" href="#values" id="values"><h3>Values</h3></a>
<p>In order to make it clear what is 'stuck' and what still needs to be evaluated,
we separate our syntax into <a href="https://en.wikipedia.org/wiki/Lambda_calculus_definition#Weak_head_normal_form">weak head normal forms</a> (\(\wexpr\)),
and neutral terms (\(\nexpr\)):</p>
<p>\[
\begin{array}{rrll}
\vexpr,\vtype   &amp; ::= &amp; \wexpr                              &amp; \text{weak head normal forms} \\
&amp;   | &amp; \nexpr                              &amp; \text{neutral terms} \\
\\
\nexpr,\ntype   &amp; ::= &amp; x                                   &amp; \text{variables} \\
&amp;   | &amp; \app{\nexpr}{\texpr}                &amp; \text{function application} \\
&amp;   | &amp; \ifte{\nexpr_1}{\texpr_2}{\texpr_3} &amp; \text{if expressions} \\
&amp;   | &amp; \case{\nexpr}{\overline{\tpat_i \rightarrow \texpr_i}^{;}}
&amp; \text{case expressions} \\
&amp;   | &amp; \nexpr.l                            &amp; \text{record projection} \\
\\
\wexpr,\wtype   &amp; ::= &amp; \Type_i                             &amp; \text{universe of types ($i \in \mathbb{N}$)} \\
&amp;   | &amp; \Bool                               &amp; \text{type of booleans} \\
&amp;   | &amp; \true ~|~ \false                    &amp; \text{boolean literals} \\
&amp;   | &amp; \Pi{x:\vtype_1}{\vtype_2}           &amp; \text{dependent function type} \\
&amp;   | &amp; \lam{x:\vtype}{\vexpr}              &amp; \text{functions} \\
&amp;   | &amp; \Record{l:\vtype_1, \vtype_2}       &amp; \text{record type extension} \\
&amp;   | &amp; \Record{}                           &amp; \text{empty record type} \\
&amp;   | &amp; \record{l=\vexpr_1, \vexpr_2}       &amp; \text{record extension} \\
&amp;   | &amp; \record{}                           &amp; \text{empty record} \\
\\
\end{array}
\]</p>
<a class="header" href="#contexts" id="contexts"><h3>Contexts</h3></a>
<p>As we type check terms, we'll be passing over bindings like lambdas and pi types.
Contexts allow us to keep track of the bound parameters,
even though we don't know the exact values these will eventually take during normalization.</p>
<p>\[
\begin{array}{rrll}
\Gamma,\Delta  &amp; ::= &amp; \varnothing          &amp; \text{the empty context} \\
&amp;   | &amp; \Gamma,x:\vtype      &amp; \text{context extended with a type claim} \\
&amp;   | &amp; \Gamma,x=\texpr      &amp; \text{context extended with a definition} \\
\end{array}
\]</p>
<a class="header" href="#semantics" id="semantics"><h2>Semantics</h2></a>
<p>We take a <em>bidirectional</em> approach to type checking, splitting it into two
phases: type checking and type inference. This makes the flow of information
through the type checker clear and relatively easy to reason about.
Normalization happens after inference, and before types are fed back in to be
used during type checking.</p>
<p>With that in mind, the next sections will describe the following judgments:</p>
<table><thead><tr><th> name                                                      </th><th> notation                                                         </th><th> inputs                                   </th><th> outputs                                 </th></tr></thead><tbody>
<tr><td> <a href="#normalization">normalization</a>                           </td><td> \(\eval{ \Gamma }{ \texpr }{ \vexpr }\)                        </td><td> \(\Gamma\), \(\rexpr\)               </td><td> \(\vexpr\)                            </td></tr>
<tr><td> <a href="#type-checking">type checking</a>                           </td><td> \(\check{ \Gamma }{ \rexpr }{ \vtype }{ \texpr }\)             </td><td> \(\Gamma\), \(\rexpr\), \(\vtype\) </td><td> \(\texpr\)                            </td></tr>
<tr><td> <a href="#type-inference">type inference</a>                         </td><td> \(\infer{ \Gamma }{ \rexpr }{ \vtype }{ \texpr }\)             </td><td> \(\Gamma\), \(\rexpr\)               </td><td> \(\vtype\), \(\texpr\)              </td></tr>
<tr><td> <a href="#pattern-matching">pattern matching</a>                     </td><td> \(\match{ \wexpr }{ \tpat }{ \theta }\)                        </td><td> \(\wexpr\), \(\tpat\)                </td><td> \(\theta\)                            </td></tr>
<tr><td> <a href="#type-checking-of-patterns">type checking of patterns</a>   </td><td> \(\checkpat{ \Gamma }{ \rpat }{ \vtype }{ \tpat }{ \Delta }\)  </td><td> \(\Gamma\), \(\rpat\), \(\vtype\)  </td><td> \(\tpat\), \(\Delta\)               </td></tr>
<tr><td> <a href="#type-inference-of-patterns">type inference of patterns</a> </td><td> \(\inferpat{ \Gamma }{ \rpat }{ \vtype }{ \tpat }{ \Delta }\)  </td><td> \(\Gamma\), \(\rpat\),               </td><td> \(\vtype\), \(\tpat\), \(\Delta\) </td></tr>
</tbody></table>
<p>Normalization stands on its own, but both checking and inference are mutually
dependent on each other. Care has been taken to design the judgments so that
they are <em>syntax-directed</em>, meaning that an algorithm can be clearly derived
from them.</p>
<p>Here is a rough overview of how Pikelet terms are checked:</p>
<pre><code>                (from parser)
                      |
                      v
     +---------- raw::Term -----------+
     |                                |
     v                                v
Type Inference &lt;- - - - - - -&gt; Type checking
     |                                ^
     |                                |
 core::Term                      core::Value
     |                                |
     +-------&gt; Normalization ---------+
     |
     |
     v
 (to compiler)
</code></pre>
<blockquote>
<p><strong>TODO:</strong>
Use SVG for this diagram</p>
</blockquote>
<a class="header" href="#elaboration" id="elaboration"><h3>Elaboration</h3></a>
<p>Elaboration is the process of filling in missing information that the
programmer omitted in the original code, generally based on the results
of type inference.</p>
<p>In Pikelet's judgements the elaborated terms are denoted after the
diamond: \(\rhd\). At the moment not much is added - only the missing
type annotations on function parameters. In the future this could be extended
filling in type class instances and implicit arguments.</p>
<a class="header" href="#normalization" id="normalization"><h3>Normalization</h3></a>
<p>Here we describe how we normalize elaborated terms under the assumptions
in the context.</p>
<p>\[
\boxed{
\eval{ \Gamma }{ \texpr }{ \vexpr }
}
\\[2em]
\begin{array}{cl}
\rule{E-ANN}{
\eval{ \Gamma }{ \texpr }{ \vexpr }
}{
\eval{ \Gamma }{ \texpr:\ttype }{ \vexpr }
}
\\[2em]
\rule{E-TYPE}{}{
\eval{ \Gamma }{ \Type_i }{ \Type_i }
}
\\[2em]
\rule{E-BOOL}{}{
\eval{ \Gamma }{ \Bool }{ \Bool }
}
\\[2em]
\rule{E-TRUE}{}{
\eval{ \Gamma }{ \true }{ \true }
}
\\[2em]
\rule{E-FALSE}{}{
\eval{ \Gamma }{ \false }{ \false }
}
\\[2em]
\rule{E-VAR}{
x=\texpr \notin \Gamma
}{
\eval{ \Gamma }{ x }{ x }
}
\\[2em]
\rule{E-VAR-DEF}{
x=\texpr \in \Gamma
\qquad
\eval{ \Gamma }{ \texpr }{ \vexpr }
}{
\eval{ \Gamma }{ x }{ \vexpr }
}
\\[2em]
\rule{E-PI}{
\eval{ \Gamma }{ \ttype_1 }{ \vtype_1 }
\qquad
\eval{ \Gamma }{ \ttype_2 }{ \vtype_2 }
}{
\eval{ \Gamma }{ \Pi{x:\ttype_1}{\ttype_2} }{ \Pi{x:\vtype_1}{\vtype_2} }
}
\\[2em]
\rule{E-LAM}{
\eval{ \Gamma }{ \ttype }{ \vtype }
\qquad
\eval{ \Gamma }{ \texpr }{ \vexpr }
}{
\eval{ \Gamma }{ \lam{x:\ttype}{\texpr} }{ \lam{x:\vtype}{\vexpr} }
}
\\[2em]
\rule{E-APP}{
\eval{ \Gamma }{ \texpr_1 }{ \lam{x:\vtype_1}{\vexpr_1} }
\qquad
\eval{ \Gamma }{ \subst{\vexpr_1}{x}{\texpr_2} }{ \vexpr_3 }
}{
\eval{ \Gamma }{ \app{\texpr_1}{\texpr_2} }{ \vexpr_3 }
}
\\[2em]
\rule{E-IF}{
\eval{ \Gamma }{ \nexpr }{ \nexpr' }
}{
\eval{ \Gamma }{ \ifte{\nexpr}{\texpr_1}{\texpr_2} }{ \ifte{\nexpr'}{\texpr_1}{\texpr_2} }
}
\\[2em]
\rule{E-IF-TRUE}{
\eval{ \Gamma }{ \nexpr }{ \true }
\qquad
\eval{ \Gamma }{ \texpr_1 }{ \vexpr_1 }
}{
\eval{ \Gamma }{ \ifte{\nexpr}{\texpr_1}{\texpr_2} }{ \vexpr_1 }
}
\\[2em]
\rule{E-IF-FALSE}{
\eval{ \Gamma }{ \nexpr }{ \false }
\qquad
\eval{ \Gamma }{ \texpr_2 }{ \vexpr_2 }
}{
\eval{ \Gamma }{ \ifte{\nexpr}{\texpr_1}{\texpr_2} }{ \vexpr_2 }
}
\\[2em]
\rule{E-CASE}{
\eval{ \Gamma }{ \nexpr }{ \nexpr' }
}{
\eval{ \Gamma }{ \case{\nexpr}{\overline{\tpat_i \rightarrow \texpr_i}^{;}} }
{ \case{\nexpr'}{\overline{\tpat_i \rightarrow \texpr_i}^{;}} }
}
\\[2em]
\rule{E-CASE-MATCH}{
\eval{ \Gamma }{ \nexpr }{ \wexpr }
\qquad
\match{ \wexpr }{ \tpat_i }{ \theta }
\qquad
\eval{ \Gamma }{ \texpr_i ~ \theta }{ \vexpr_i }
}{
\eval{ \Gamma }{ \case{\nexpr}{\overline{\tpat_i \rightarrow \texpr_i}^{;}} }{ \vexpr_i }
}
\\[2em]
\rule{E-RECORD-TYPE}{
\eval{ \Gamma }{ \ttype_1 }{ \vtype_1 }
\qquad
\eval{ \Gamma }{ \ttype_2 }{ \vtype_2 }
}{
\eval{ \Gamma }{ \Record{l:\ttype_1, \ttype_2} }{ \Record{l:\vtype_1, \vtype_2} }
}
\\[2em]
\rule{E-RECORD}{
\eval{ \Gamma }{ \texpr_1 }{ \vexpr_1 }
\qquad
\eval{ \Gamma }{ \texpr_2 }{ \vexpr_2 }
}{
\eval{ \Gamma }{ \record{l=\texpr_1, \texpr_2} }{ \record{l=\vexpr_1, \vexpr_2} }
}
\\[2em]
\rule{E-EMPTY-RECORD-TYPE}{}{
\eval{ \Gamma }{ \Record{} }{ \Record{} }
}
\\[2em]
\rule{E-EMPTY-RECORD}{}{
\eval{ \Gamma }{ \record{} }{ \record{} }
}
\\[2em]
\rule{E-PROJ}{
\eval{ \Gamma }{ \texpr_1 }{ \vexpr_1 }
\qquad
\vexpr_2 = \field(l, \vexpr_1)
}{
\eval{ \Gamma }{ \texpr_1.l }{ \vexpr_2 }
}
\\[2em]
\end{array}
\]</p>
<p>We define \(\field(-,-)\) like so:</p>
<p>\[
\begin{array}{lrll}
\field(l_1, \record{l_2 = \vexpr_1, \vexpr_2}) &amp; = &amp; \vexpr_1 &amp; \text{if} ~ l_1 \equiv l_2 \\
\field(l_1, \record{l_2 = \vexpr_1, \vexpr_2}) &amp; = &amp; \field(l_1, \vexpr_2) \\
\end{array}
\]</p>
<a class="header" href="#type-checking" id="type-checking"><h3>Type checking</h3></a>
<p>This judgement checks that the given term has the expected type and returns its
elaborated form.</p>
<p>\[
\boxed{
\check{ \Gamma }{ \rexpr }{ \vtype }{ \texpr }
}
\\[2em]
\begin{array}{cl}
\rule{C-LAM}{
\infer{ \Gamma,x:\vtype_1 }{ \rexpr }{ \ttype_2 }{ \texpr }
}{
\check{ \Gamma }{ \lam{x}{\rexpr} }{ \Pi{x:\vtype_1}{\vtype_2} }{ \lam{x:\vtype_1}{\texpr} }
}
\\[2em]
\rule{C-IF}{
\check{ \Gamma }{ \rexpr_1 }{ \Bool }{ \texpr_1 }
\qquad
\check{ \Gamma }{ \rexpr_2 }{ \vtype }{ \texpr_2 }
\qquad
\check{ \Gamma }{ \rexpr_3 }{ \vtype }{ \texpr_3 }
}{
\check{ \Gamma }{ \ifte{\rexpr_1}{\rexpr_2}{\rexpr_3} }{ \vtype }{ \ifte{\texpr_1}{\texpr_2}{\texpr_3} }
}
\\[2em]
\rule{C-CASE}{
\infer{ \Gamma }{ \rexpr }{ \vtype_1 }{ \texpr }
\qquad
\overline{
% TODO: impl pattern checks
~
\check{ \Gamma }{ \rpat_i }{ \vtype_1 }{ \tpat_i } \Rightarrow \Delta
\qquad
\check{ \Gamma \sim \Delta }{ \rexpr_i }{ \vtype_2 }{ \texpr_i }
~
}
}{
\check{ \Gamma }{ \case{\rexpr}{\overline{\rpat_i \rightarrow \rexpr_i}^{;}} }{ \vtype_2 }
{ \case{\texpr}{\overline{\tpat_i \rightarrow \texpr_i}^{;}} }
}
\\[2em]
\rule{C-RECORD}{
l_1 \equiv l_2
\qquad
\check{ \Gamma }{ \rexpr_1 }{ \vtype_1 }{ \texpr_1 }
\qquad
\eval{ \Gamma }{ \subst{\vtype_2}{l_1}{\texpr_1} }{ \vtype_3 }
\qquad
\check{ \Gamma }{ \rexpr_2 }{ \vtype_3 }{ \texpr_2 }
}{
\check{ \Gamma }{ \record{l_1=\rexpr_1, \rexpr_2} }{ \Record{l_2:\vtype_1, \vtype_2} }{ \record{l_1=\texpr_1, \texpr_2} }
}
\\[2em]
\rule{C-CONV}{
\infer{ \Gamma }{ \rexpr }{ \vtype_2 }{ \texpr }
\qquad
\vtype_1 \equiv_{\alpha} \vtype_2
}{
\check{ \Gamma }{ \rexpr }{ \vtype_1 }{ \texpr }
}
\\[2em]
\end{array}
\]</p>
<p>In C-CONV we flip the direction of the type checker, comparing the type of the
expected term for <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence">alpha equivalence</a> with the inferred term. Note that we could
alternatively check for subtyping instead of alpha equivalence. This could be
useful for implementing a cumulative universe hierarchy.</p>
<a class="header" href="#type-inference-1" id="type-inference-1"><h3>Type inference</h3></a>
<p>Here we define a judgement that synthesizes a type from the given term and
returns its elaborated form.</p>
<p>\[
\boxed{
\infer{ \Gamma }{ \rexpr }{ \vtype }{ \texpr }
}
\\[2em]
\begin{array}{cl}
\rule{I-ANN}{
\infer{ \Gamma }{ \rtype }{ \Type_i }{ \ttype }
\qquad
\eval{ \Gamma }{ \ttype }{ \vtype }
\qquad
\check{ \Gamma }{ \rexpr }{ \vtype }{ \texpr }
}{
\infer{ \Gamma }{ \rexpr:\rtype }{ \Type_{i+1} }{ \texpr:\ttype }
}
\\[2em]
\rule{I-TYPE}{}{
\infer{ \Gamma }{ \Type_i }{ \Type_{i+1} }{ \Type_i }
}
\\[2em]
\rule{I-BOOL}{}{
\infer{ \Gamma }{ \Bool }{ \Type_0 }{ \Bool }
}
\\[2em]
\rule{I-TRUE}{}{
\infer{ \Gamma }{ \true }{ \Bool }{ \true }
}
\\[2em]
\rule{I-FALSE}{}{
\infer{ \Gamma }{ \false }{ \Bool }{ \false }
}
\\[2em]
\rule{I-VAR}{
x:\vtype \in \Gamma
}{
\infer{ \Gamma }{ x }{ \vtype }{ x }
}
\\[2em]
\rule{I-PI}{
\infer{ \Gamma }{ \rtype_1 }{ \Type_i }{ \ttype_1 }
\qquad
\eval{ \Gamma }{ \ttype_1 }{ \vtype_1 }
\qquad
\check{ \Gamma, x:\vtype_1 }{ \rtype_2 }{ \Type_j }{ \ttype_2 }
}{
\infer{ \Gamma }{ \Pi{x:\rtype_1}{\rtype_2} }{ \Type_{\max(i,j)} }{ \Pi{x:\ttype_1}{\ttype_2} }
}
\\[2em]
\rule{I-LAM}{
\infer{ \Gamma }{ \rtype }{ \Type_i }{ \ttype }
\qquad
\eval{ \Gamma }{ \ttype }{ \vtype_1 }
\qquad
\check{ \Gamma, x:\vtype_1 }{ \rexpr}{ \vtype_2 }{ \texpr }
}{
\infer{ \Gamma }{ \lam{x:\rtype}{\rexpr} }{ \Pi{x:\vtype_1}{\vtype_2} }{ \lam{x:\ttype}{\texpr} }
}
\\[2em]
\rule{I-APP}{
\infer{ \Gamma }{ \rexpr_1 }{ \Pi{x:\vtype_1}{\vtype_2} }{ \texpr_1 }
\qquad
\check{ \Gamma }{ \rexpr_2 }{ \vtype_1 }{ \texpr_2 }
\qquad
\eval{ \Gamma }{ \subst{\vtype_2}{x}{\texpr_2} }{ \vtype_3 }
}{
\infer{ \Gamma }{ \app{\rexpr_1}{\rexpr_2} }{ \vtype_3 }{ \app{\texpr_1}{\texpr_2} }
}
\\[2em]
\rule{I-RECORD-TYPE}{
\infer{ \Gamma }{ \rtype_1 }{ \Type_i }{ \ttype_1 }
\qquad
\eval{ \Gamma }{ \ttype_1 }{ \vtype_1 }
\qquad
\infer{ \Gamma, x:\vtype_1 }{ \rtype_2 }{ \Type_j }{ \ttype_2 }
}{
\infer{ \Gamma }{ \Record{l:\rtype_1, \rtype_2} }{ \Type_{\max(i,j)} }{ \Record{l:\ttype_1, \ttype_2} }
}
\\[2em]
\rule{I-EMPTY-RECORD-TYPE}{}{
\infer{ \Gamma }{ \Record{} }{ \Type_0 }{ \Record{} }
}
\\[2em]
\rule{I-EMPTY-RECORD}{}{
\infer{ \Gamma }{ \record{} }{ \Record{} }{ \record{} }
}
\\[2em]
\rule{I-PROJ}{
\infer{ \Gamma }{ \rexpr }{ \vtype_1 }{ \texpr }
\qquad
\vtype_2 = \fieldty(l, \vtype_1)
\qquad
\theta = \fieldsubst(\texpr, l, \vtype_1)
}{
\infer{ \Gamma }{ \rexpr.l }{ \vtype_2 ~ \theta }{ \texpr.l }
}
\\[2em]
\end{array}
\]</p>
<p>We define \(\fieldty(-,-)\) and \(\fieldsubst(-,-,-)\) like so:</p>
<p>\[
\begin{array}{lrll}
\fieldty(l_1, \Record{l_2 : \vtype_1, \vtype_2}) &amp; = &amp; \vtype_1 &amp; \text{if} ~ l_1 \equiv l_2 \\
\fieldty(l_1, \Record{l_2 : \vtype_1, \vtype_2}) &amp; = &amp; \fieldty(l_1, \vtype_2) \\
\\[2em]
\end{array}
\]</p>
<p>In order to ensure that we maintain maintain the proper paths to variables when
we project on them, we define \(\fieldsubst(-,-,-)\) as:</p>
<p>\[
\begin{array}{lrll}
\fieldsubst(\texpr, l_1, \Record{l_2 : \vtype_1, \vtype_2}) &amp; =
&amp; [] &amp; \text{if} ~ l_1 \equiv l_2 \\
\fieldsubst(\texpr, l_1, \Record{l_2 : \vtype_1, \vtype_2}) &amp; =
&amp; \fieldsubst(\texpr, l_1, \vtype_2) \doubleplus [ l_2 \rightarrow \texpr.l_2 ] \\
\\[2em]
\end{array}
\]</p>
<a class="header" href="#pattern-matching" id="pattern-matching"><h3>Pattern matching</h3></a>
<p>This judement takes an expression \(\wexpr\) in weak head normal form, and a
pattern \(\tpat\) and returns a substitution \(\theta\) with the matched bindings.</p>
<p>\[
\boxed{
\match{ \wexpr }{ \tpat }{ \theta }
}
\\[2em]
\begin{array}{cl}
\rule{M-VAR}{}{
\match{ \wexpr }{ x }{ [x \rightarrow \wexpr] }
}
\\[2em]
\rule{M-TRUE}{}{
\match{ \true }{ \true }{ [] }
}
\\[2em]
\rule{M-FALSE}{}{
\match{ \false }{ \false }{ [] }
}
\\[2em]
% TODO:
%   \rule{M-RECORD}{
%       \match{ \wexpr_1 }{ \tpat_1 }{ \theta_1 }
%       \qquad
%       \match{ \wexpr_2 }{ \tpat_2 }{ \theta_2 }
%   }{
%       \match{ \record{l=\wexpr_1, \wexpr_2} }{ \record{l=\tpat_1, \tpat_2} }{ \theta_1 \doubleplus \theta_2 }
%   }
%   \\[2em]
%   \rule{M-EMPTY-RECORD}{}{
%       \match{ \record{} }{ \record{} }{ [] }
%   }
%   \\[2em]
\end{array}
\]</p>
<a class="header" href="#type-checking-of-patterns" id="type-checking-of-patterns"><h3>Type checking of patterns</h3></a>
<p>\[
\boxed{
\checkpat{ \Gamma }{ \rpat }{ \vtype }{ \tpat }{ \Delta }
}
\\[2em]
\begin{array}{cl}
\rule{CP-BINDER}{}{
\checkpat{ \Gamma }{ x }{ \vtype }{ x }{ x : \vtype }
}
\\[2em]
\rule{CP-CONV}{
\inferpat{ \Gamma }{ \rpat }{ \vtype_2 }{ \tpat }{ \Delta }
\qquad
\vtype_1 \equiv_{\alpha} \vtype_2
}{
\checkpat{ \Gamma }{ \rpat }{ \vtype_1 }{ \tpat }{ \Delta }
}
\\[2em]
\end{array}
\]</p>
<a class="header" href="#type-inference-of-patterns" id="type-inference-of-patterns"><h3>Type inference of patterns</h3></a>
<p>\[
\boxed{
\inferpat{ \Gamma }{ \rpat }{ \vtype }{ \tpat }{ \Delta }
}
\\[2em]
\begin{array}{cl}
\rule{IP-ANN}{
\infer{ \Gamma }{ \rtype }{ \Type_i }{ \ttype }
\qquad
\eval{ \Gamma }{ \ttype }{ \vtype }
\qquad
\checkpat{ \Gamma }{ \rpat }{ \vtype }{ \rpat }{ \Delta }
}{
\inferpat{ \Gamma }{ \rpat : \rtype }{ \rtype }{ \rpat : \rtype }{ \Delta }
}
\\[2em]
\rule{IP-TRUE}{}{
\inferpat{ \Gamma }{ \true }{ \Bool }{ \true }{ \varnothing }
}
\\[2em]
\rule{IP-FALSE}{}{
\inferpat{ \Gamma }{ \false }{ \Bool }{ \false }{ \varnothing }
}
\\[2em]
\end{array}
\]</p>
<blockquote>
<p><strong>TODO:</strong></p>
<ul>
<li>Coverage (ie. that a series of patterns covers all possible values)</li>
<li>Ensure that parametericity is maintained. Should we forbid <a href="https://stackoverflow.com/questions/45439486/pattern-matching-on-type-in-idris">pattern matching
directly on types</a>? McBride seems to <a href="https://stackoverflow.com/questions/23220884/why-is-typecase-a-bad-thing/26012264#26012264">think we can have our
cake and eat it</a>!</li>
</ul>
</blockquote>
<a class="header" href="#compiler-architecture" id="compiler-architecture"><h1>Compiler Architecture</h1></a>
<p>In order to create a separation of concerns, we break up our compiler into many
small stages, beginning with a source string, and ultimately ending up with
compiled machine code.</p>
<p>Below is a rough flow chart showing how source strings are currently lexed,
parsed, desugared, and type checked/elaborated:</p>
<pre><code class="language-bob">         .------------.
         |   String   |
         '------------'
                |
      syntax::parse::lexer
                |
                v
  .-----------------------------.
  | syntax::parse::lexer::Token |
  '-----------------------------'
                |
     syntax::parse::grammar
                |
                v
    .------------------------.
    | syntax::concrete::Term |
    '------------------------'
                |
   syntax::translation::desugar
                |
                v
      .-------------------.
      | syntax::raw::Term |
      '-------------------'
                |                        .---------------------.
    semantics::{check,infer} &lt;---------- | syntax::core::Value |
                |                        '---------------------'
                v                                    ^
      .--------------------.                         |
      | syntax::core::Term | - semantics::normalize -'
      '--------------------'
                |
                v
    TODO: compiler back end(s)
</code></pre>
<p>As you can see we have only built the front-end as of the time of writing. When
we begin to build out a <a href="https://github.com/pikelet-lang/pikelet/issues/9">compiler back end</a>,
more stages will be added after type checking and elaboration.</p>
<a class="header" href="#name-binding" id="name-binding"><h2>Name binding</h2></a>
<p>Name binding is a surprisingly challenging thing to implement in type checkers
and compilers. We use the <a href="https://github.com/brendanzab/moniker"><code>moniker</code> crate</a>
for this. Unfortunately this uses a quite slow method of name binding, and could
result in performance blowouts in the future. This is something to keep an eye on!</p>
<a class="header" href="#performance-considerations" id="performance-considerations"><h2>Performance considerations</h2></a>
<p>As you can see from the diagram above, this architecture leads to an
easy-to-reason about pipeline. It does however result in the creation of lots of
intermediate allocations of heap-allocated tree data structures that will
ultimately be discarded. This is quite similar to the problem we face with
iterators:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 'internal' iteration
vec![1, 2, 3].map(|x| x * x).filter(|x| x &lt; 3)

// 'external' iteration
vec![1, 2, 3].iter().map(|x| x * x).filter(|x| x &lt; 3).collect()
#}</code></pre></pre>
<p>The first example, which uses 'internal' iteration allocates a new collection
after each operation, resulting in three allocated collections. We can improve
the performance however by using 'external' iteration - ie. returning a series
of chained iterator adaptors, that only perform the allocation on the call to
<code>collect</code>. This emulates the 'fusion' that languages like Haskell perform to
reduce intermediate allocations.</p>
<p>We could potentially get some fusion between the stages of our compiler by way
of the <a href="https://github.com/pikelet-lang/pikelet/issues/75">visitor pattern</a>.</p>
<a class="header" href="#support-for-interactive-development" id="support-for-interactive-development"><h2>Support for interactive development</h2></a>
<p>It would be interesting to see how Pikelet could be implemented using an
asynchronous, query-based architecture. This will become more important as the
demands of interactive development and incremental compilation become more
pressing. In this model we would have to think of compilation as less a pure
function from source code to machine code, and more as interacting with a
database. Perhaps a CQRS (Command-Query-Responsibility-Segregation) model would
be useful for this?</p>
<a class="header" href="#resources" id="resources"><h3>Resources</h3></a>
<ul>
<li><a href="https://rust-lang-nursery.github.io/rustc-guide/query.html">Queries: demand-driven compilation (Rustc Book)</a></li>
<li><a href="https://www.youtube.com/watch?v=wSdV1M7n4gQ">Anders Hejlsberg on Modern Compiler Construction (YouTube)</a></li>
</ul>
<a class="header" href="#influences" id="influences"><h1>Influences</h1></a>
<p>Some languages have been inspiring when building Pikelet. We list some of them
here, and the contributions they have made in our thinking. These ideas may or
may not be included in the final Pikelet language, but they are worth mentioning!</p>
<a class="header" href="#contents-5" id="contents-5"><h2>Contents</h2></a>
<ul>
<li><a href="#1ml">1ML</a></li>
<li><a href="#agda">Agda</a></li>
<li><a href="#ats">ATS</a></li>
<li><a href="#d">D</a></li>
<li><a href="#dhall">Dhall</a></li>
<li><a href="#discus-formerly-ddc">Discus (formerly DDC)</a></li>
<li><a href="#elm">Elm</a></li>
<li><a href="#f">F*</a></li>
<li><a href="#gluon">Gluon</a></li>
<li><a href="#granule">Granule</a></li>
<li><a href="#idris">Idris</a></li>
<li><a href="#ivory">Ivory</a></li>
<li><a href="#koka">Koka</a></li>
<li><a href="#lean">Lean</a></li>
<li><a href="#ocaml">OCaml</a></li>
<li><a href="#rust">Rust</a></li>
<li><a href="#sixten">Sixten</a></li>
<li><a href="#ur">Ur</a></li>
</ul>
<a class="header" href="#a1ml" id="a1ml"><h2>1ML</h2></a>
<p>Links:</p>
<ul>
<li><a href="https://people.mpi-sws.org/%7Erossberg/1ml/">Website</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>focus on simplicity</li>
<li>combines module language of ML with dependent records</li>
<li>formalized foundation</li>
</ul>
<a class="header" href="#agda" id="agda"><h2>Agda</h2></a>
<p>Links:</p>
<ul>
<li><a href="http://wiki.portal.chalmers.se/agda/pmwiki.php">Wiki</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>interactive editing</li>
<li>dependent types</li>
<li>dependent records</li>
<li>implicit arguments</li>
<li>instance arguments for emulating type classes</li>
<li>codata for unbounded data</li>
<li>totality checking</li>
<li>inductive data types</li>
</ul>
<a class="header" href="#ats" id="ats"><h2>ATS</h2></a>
<p>Links:</p>
<ul>
<li><a href="http://www.ats-lang.org/">Website</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>dependent types</li>
<li>proofs can be generated by SMT solvers</li>
<li>high level of performance, low level interoperability</li>
<li>unboxed data types</li>
</ul>
<a class="header" href="#d" id="d"><h2>D</h2></a>
<p>Links:</p>
<ul>
<li><a href="http://dlang.org">Website</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>strong support for static metaprogramming</li>
<li><a href="https://dconf.org/2017/talks/alexandrescu.pdf">design by introspection</a>
(ie. breaking parametricity for performance optimization and metaprogramming purposes)</li>
<li>low-level control and high-level abstraction</li>
<li>fast compiler, short iteration times</li>
</ul>
<a class="header" href="#dhall" id="dhall"><h2>Dhall</h2></a>
<p>Links:</p>
<ul>
<li><a href="https://github.com/dhall-lang/">Website</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>simple core language</li>
<li>dependent types</li>
<li>total language</li>
<li>structural records</li>
</ul>
<a class="header" href="#discus-formerly-ddc" id="discus-formerly-ddc"><h2>Discus (formerly DDC)</h2></a>
<p>Links:</p>
<ul>
<li><a href="http://www.discus-lang.org/">Website</a></li>
</ul>
<a class="header" href="#elm" id="elm"><h2>Elm</h2></a>
<p>Links:</p>
<ul>
<li><a href="http://elm-lang.org/">Website</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>focus on usability, and adoption</li>
<li>friendly marketing</li>
<li>welcoming community</li>
<li>best-in-class error messages</li>
<li>row polymorphism</li>
</ul>
<a class="header" href="#f" id="f"><h2>F*</h2></a>
<p>Links:</p>
<ul>
<li><a href="https://www.fstar-lang.org/">Website</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>combining SMT solvers with explicit proofs</li>
<li>combining effects with dependent types</li>
</ul>
<a class="header" href="#gluon" id="gluon"><h2>Gluon</h2></a>
<p>Links:</p>
<ul>
<li><a href="https://github.com/gluon-lang/gluon">Repository</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>strict evaluation</li>
<li>focus on simplicity</li>
<li>embeddable in Rust programs</li>
<li>using records as a basis for the module system</li>
</ul>
<a class="header" href="#granule" id="granule"><h2>Granule</h2></a>
<p>Links:</p>
<ul>
<li><a href="https://github.com/dorchard/granule/">Repository</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>combining coeffects with effects in one language</li>
</ul>
<a class="header" href="#idris" id="idris"><h2>Idris</h2></a>
<p>Links:</p>
<ul>
<li><a href="https://www.idris-lang.org/">Website</a></li>
<li><a href="http://docs.idris-lang.org">Documentation</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>focus on making dependently typed programming practical</li>
<li>interactive editing</li>
<li>simple core type theory</li>
<li>opt-out totality checking</li>
<li>nice, accessible documentation, focused on real-world examples</li>
<li>universe checking</li>
<li>aggressive erasure</li>
<li>linear types</li>
<li>compilation to native code</li>
<li>elaborator reflection</li>
<li>ad-hoc interfaces desugar into records</li>
<li>effects system as a library</li>
<li>state machine library</li>
</ul>
<a class="header" href="#ivory" id="ivory"><h2>Ivory</h2></a>
<p>Links:</p>
<ul>
<li><a href="https://ivorylang.org/ivory-introduction.html">Website</a></li>
</ul>
<a class="header" href="#koka" id="koka"><h2>Koka</h2></a>
<p>Links:</p>
<ul>
<li><a href="https://www.microsoft.com/en-us/research/project/koka/">Website</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>algebraic effects and handlers</li>
<li>nice library documentation, with clickable links, etc.</li>
</ul>
<a class="header" href="#lean" id="lean"><h2>Lean</h2></a>
<p>Links:</p>
<ul>
<li><a href="http://leanprover.github.io">Website</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>focus on responsive interactive development</li>
<li>metaprogramming support using Lean</li>
<li>simple kernel language</li>
</ul>
<a class="header" href="#ocaml" id="ocaml"><h2>OCaml</h2></a>
<p>Links:</p>
<ul>
<li><a href="https://ocaml.org/">Website</a></li>
<li><a href="https://github.com/ocamllabs/ocaml-multicore">Repository (Multicore)</a></li>
<li><a href="https://github.com/ocamllabs/ocaml-modular-implicits">Repository (Modular implicits)</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>module system</li>
<li>algebraic effects</li>
<li>modular implicits</li>
<li>row polymorphism</li>
<li>structural records</li>
<li>efficient (and <em>fast</em>) code generation</li>
</ul>
<a class="header" href="#rust" id="rust"><h2>Rust</h2></a>
<p>Links:</p>
<ul>
<li><a href="http://rust-lang.org/">Website</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>friendly community</li>
<li>non-uniform, unboxed data layout</li>
<li>predictable optimizations</li>
<li>focus on systems programming</li>
<li>having safety and low level code under one roof</li>
<li>infectious 'unsafe' keyword</li>
<li>strict evaluation</li>
<li>opt-in garbage collection</li>
<li>minimal runtime</li>
<li>bootstrapped itself off a foundation of C libraries</li>
</ul>
<a class="header" href="#sixten" id="sixten"><h2>Sixten</h2></a>
<p>Links:</p>
<ul>
<li><a href="https://github.com/ollef/sixten">Repository</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>non-uniform, unboxed data layout</li>
<li>dependent types</li>
</ul>
<a class="header" href="#ur" id="ur"><h2>Ur</h2></a>
<p>Links:</p>
<ul>
<li><a href="http://www.impredicative.com/ur/">Website</a></li>
</ul>
<p>Key things we love:</p>
<ul>
<li>Statically typed metaprogramming with type-level records</li>
</ul>
<a class="header" href="#references" id="references"><h1>References</h1></a>
<p>What follows is a non-exhaustive list of some of the references that were useful
when building Pikelet:</p>
<ul>
<li>Christiansen, David Raymond (2013). “Bidirectional Typing Rules: A Tutorial”.
[<a href="http://www.davidchristiansen.dk/tutorials/bidirectional.pdf">PAPER</a>]</li>
<li>Löh, Andres, McBride, Conor and Swierstra, Wouter (2009). “A tutorial
implementation of a dependently typed lambda calculus”.
[<a href="https://www.andres-loeh.de/LambdaPi/">SITE</a>]
[<a href="https://www.andres-loeh.de/LambdaPi/LambdaPi.pdf">PAPER</a>]</li>
<li>Norell, Ulf (2007). “Towards a practical programming language based on
dependent type theory”.
[<a href="http://www.cse.chalmers.se/%7Eulfn/papers/thesis.pdf">PAPER</a>]</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        <script>
            var path_to_root = "";
        </script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
